/**
 * Application YesData Frequentation - Script principal
 * Gestion de la navigation et interactions utilisateur
 */

class YesDataApp {
    constructor() {
        this.currentPage = 'chargement';
        this.pages = ['chargement', 'monitoring', 'database'];
        this.init();
    }

    /**
     * Initialisation de l'application
     */
    init() {
        this.setupEventListeners();
        this.updatePageTitle();
        this.showWelcomeMessage();
        this.initCanvasMenu();
        console.log('‚úÖ Application YesData Frequentation initialis√©e avec succ√®s - Style YesData');
    }

    /**
     * Configuration des √©couteurs d'√©v√©nements
     */
    setupEventListeners() {
        // Navigation entre les pages
        const navButtons = document.querySelectorAll('.nav-btn');
        console.log(`üîç Boutons de navigation trouv√©s: ${navButtons.length}`);
        navButtons.forEach((button, index) => {
            const page = button.dataset.page;
            console.log(`üîç Bouton ${index + 1}: ${page}`);
            button.addEventListener('click', (e) => {
                const targetPage = e.currentTarget.dataset.page;
                console.log(`üñ±Ô∏è Clic sur le bouton de navigation: ${targetPage}`);
                this.navigateToPage(targetPage);
            });
        });

        // Raccourcis clavier
        document.addEventListener('keydown', (e) => {
            this.handleKeyboardShortcuts(e);
        });

        // Gestion du redimensionnement de la fen√™tre
        window.addEventListener('resize', () => {
            this.handleWindowResize();
        });

        // Pr√©vention du comportement par d√©faut des boutons
        document.addEventListener('click', (e) => {
            if (e.target.type === 'button') {
                e.preventDefault();
            }
        });
    }

    /**
     * Navigation vers une page sp√©cifique
     * @param {string} pageName - Nom de la page √† afficher
     */
    navigateToPage(pageName) {
        console.log(`üöÄ Tentative de navigation vers: ${pageName}`);
        console.log(`üîç Pages disponibles: ${this.pages.join(', ')}`);
        
        if (!this.pages.includes(pageName)) {
            console.warn(`‚ö†Ô∏è Page "${pageName}" non trouv√©e dans la liste des pages disponibles`);
            return;
        }

        console.log(`‚úÖ Page "${pageName}" trouv√©e, d√©but de la navigation`);

        // Masquer toutes les pages
        console.log(`üôà Masquage de toutes les pages`);
        this.hideAllPages();

        // Afficher la page demand√©e
        console.log(`üëÅÔ∏è Affichage de la page: ${pageName}`);
        this.showPage(pageName);

        // Mettre √† jour la navigation
        console.log(`üîÑ Mise √† jour de la navigation`);
        this.updateNavigation(pageName);

        // Mettre √† jour l'√©tat courant
        this.currentPage = pageName;

        // Mettre √† jour le titre de la page
        this.updatePageTitle();

        // Log pour d√©bogage
        console.log(`üìÑ Navigation termin√©e vers la page: ${pageName}`);

        // D√©clencher un √©v√©nement personnalis√©
        this.dispatchPageChangeEvent(pageName);
    }

    /**
     * Masquer toutes les pages
     */
    hideAllPages() {
        this.pages.forEach(pageName => {
            const pageElement = document.getElementById(`${pageName}-page`);
            console.log(`üîç Recherche de l'√©l√©ment: ${pageName}-page`);
            if (pageElement) {
                console.log(`‚úÖ √âl√©ment trouv√©, masquage de: ${pageName}-page`);
                pageElement.classList.remove('active');
            } else {
                console.warn(`‚ö†Ô∏è √âl√©ment non trouv√©: ${pageName}-page`);
            }
        });
    }

    /**
     * Afficher une page sp√©cifique
     * @param {string} pageName - Nom de la page √† afficher
     */
    showPage(pageName) {
        const pageElement = document.getElementById(`${pageName}-page`);
        console.log(`üîç Recherche de l'√©l√©ment √† afficher: ${pageName}-page`);
        if (pageElement) {
            console.log(`‚úÖ √âl√©ment trouv√©, affichage de: ${pageName}-page`);
            pageElement.classList.add('active');
            
            // Animation d'entr√©e
            pageElement.style.opacity = '0';
            setTimeout(() => {
                pageElement.style.opacity = '1';
            }, 50);
        } else {
            console.error(`‚ùå Impossible de trouver l'√©l√©ment: ${pageName}-page`);
        }
    }

    /**
     * Mettre √† jour l'√©tat de la navigation
     * @param {string} activePage - Page actuellement active
     */
    updateNavigation(activePage) {
        const navButtons = document.querySelectorAll('.nav-btn');
        navButtons.forEach(button => {
            const buttonPage = button.dataset.page;
            if (buttonPage === activePage) {
                button.classList.add('active');
            } else {
                button.classList.remove('active');
            }
        });
    }

    /**
     * Mettre √† jour le titre de la page
     */
    updatePageTitle() {
        const pageNames = {
            'chargement': 'Chargement',
            'monitoring': 'Monitoring'
        };
        
        const currentPageName = pageNames[this.currentPage] || 'YesData Frequentation';
        document.title = `${currentPageName} - YesData Frequentation`;
    }

    /**
     * Gestion des raccourcis clavier
     * @param {KeyboardEvent} e - √âv√©nement clavier
     */
    handleKeyboardShortcuts(e) {
        // Alt + 1 = Page Chargement
        if (e.altKey && e.key === '1') {
            e.preventDefault();
            this.navigateToPage('chargement');
        }
        
        // Alt + 2 = Page Monitoring
        if (e.altKey && e.key === '2') {
            e.preventDefault();
            this.navigateToPage('monitoring');
        }

        // √âchap pour revenir √† la premi√®re page
        if (e.key === 'Escape') {
            this.navigateToPage('chargement');
        }
    }

    /**
     * Gestion du redimensionnement de la fen√™tre
     */
    handleWindowResize() {
        // Ajuster l'interface si n√©cessaire
        const isMobile = window.innerWidth <= 768;
        document.body.classList.toggle('mobile-view', isMobile);
    }

    /**
     * D√©clencher un √©v√©nement personnalis√© lors du changement de page
     * @param {string} pageName - Nom de la nouvelle page
     */
    dispatchPageChangeEvent(pageName) {
        const event = new CustomEvent('pageChange', {
            detail: {
                currentPage: pageName,
                previousPage: this.currentPage,
                timestamp: new Date().toISOString()
            }
        });
        
        document.dispatchEvent(event);
    }

    /**
     * Afficher un message de bienvenue dans la console
     */
    showWelcomeMessage() {
        console.log(`
üöÄ Application YesData Frequentation v1.0.0 - Style YesData Futuriste
‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ
üé® Th√®me: Design futuriste sombre avec effets visuels
üìã Modules disponibles: ${this.pages.join(', ')}
üéØ Module actuel: ${this.currentPage}
üñ•Ô∏è Canvas cylindrique: Activ√©
‚ú® Background gradients: Activ√©
‚å®Ô∏è Raccourcis:
   ‚Ä¢ Alt + 1: Module Chargement
   ‚Ä¢ Alt + 2: Module Monitoring
   ‚Ä¢ √âchap: Retour √† l'accueil
‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ
        `);
    }

    /**
     * Obtenir des informations sur l'√©tat actuel de l'application
     * @returns {Object} Informations sur l'√©tat de l'application
     */
    getAppState() {
        return {
            currentPage: this.currentPage,
            availablePages: this.pages,
            version: 'v0.000-stable-extract-viewer-database',
            timestamp: new Date().toISOString()
        };
    }

    /**
     * R√©initialiser l'application √† son √©tat initial
     */
    reset() {
        this.navigateToPage('chargement');
        console.log('üîÑ Application r√©initialis√©e');
    }

    /**
     * Initialiser le menu canvas cylindrique - Style YesData
     */
    initCanvasMenu() {
        this.drawCylMenu();
        window.addEventListener('resize', () => this.drawCylMenu());
    }

    /**
     * Dessiner le menu cylindrique - Inspir√© du projet YesData
     */
    drawCylMenu() {
        const menuCanvas = document.getElementById('menuCanvas');
        if (!menuCanvas) return;

        const header = document.querySelector('.app-header');
        if (!header) return;

        const dpr = window.devicePixelRatio || 1;
        const w = header.clientWidth;
        const h = header.clientHeight;
        
        menuCanvas.style.position = 'absolute';
        menuCanvas.style.left = '0';
        menuCanvas.style.top = '0';
        menuCanvas.style.width = w + 'px';
        menuCanvas.style.height = h + 'px';
        menuCanvas.width = Math.floor(w * dpr);
        menuCanvas.height = Math.floor(h * dpr);
        
        const ctx = menuCanvas.getContext('2d');
        ctx.scale(dpr, dpr);
        ctx.clearRect(0, 0, w, h);

        const radius = Math.min(18, h / 2 - 2);
        const padding = 8;
        const barH = Math.max(h - padding * 2, 12);
        const barW = w - padding * 2;
        const x = padding;
        const y = (h - barH) / 2;

        // Gradient principal
        const grd = ctx.createLinearGradient(0, y, 0, y + barH);
        grd.addColorStop(0, 'rgba(255,255,255,0.18)');
        grd.addColorStop(0.5, 'rgba(255,255,255,0.06)');
        grd.addColorStop(1, 'rgba(0,0,0,0.18)');

        ctx.beginPath();
        this.roundRect(ctx, x, y, barW, barH, radius);
        ctx.fillStyle = grd;
        ctx.fill();

        // Highlight sp√©culaire
        ctx.beginPath();
        this.roundRect(ctx, x + 2, y + 2, barW - 4, barH * 0.35, radius * 0.8);
        const hi = ctx.createLinearGradient(0, y + 2, 0, y + 2 + barH * 0.35);
        hi.addColorStop(0, 'rgba(255,255,255,0.25)');
        hi.addColorStop(1, 'rgba(255,255,255,0.02)');
        ctx.fillStyle = hi;
        ctx.fill();

        // Ombre du bas
        ctx.beginPath();
        this.roundRect(ctx, x + 2, y + barH * 0.6, barW - 4, barH * 0.35, radius * 0.8);
        const sh = ctx.createLinearGradient(0, y + barH * 0.6, 0, y + barH);
        sh.addColorStop(0, 'rgba(0,0,0,0.08)');
        sh.addColorStop(1, 'rgba(0,0,0,0.18)');
        ctx.fillStyle = sh;
        ctx.fill();
    }

    /**
     * Fonction utilitaire pour dessiner des rectangles arrondis
     */
    roundRect(ctx, x, y, width, height, radius) {
        const r = Math.max(0, Math.min(radius, height / 2));
        ctx.beginPath();
        ctx.moveTo(x + r, y);
        ctx.lineTo(x + width - r, y);
        ctx.quadraticCurveTo(x + width, y, x + width, y + r);
        ctx.lineTo(x + width, y + height - r);
        ctx.quadraticCurveTo(x + width, y + height, x + width - r, y + height);
        ctx.lineTo(x + r, y + height);
        ctx.quadraticCurveTo(x, y + height, x, y + height - r);
        ctx.lineTo(x, y + r);
        ctx.quadraticCurveTo(x, y, x + r, y);
        ctx.closePath();
    }
}

/**
 * Utilitaires globaux
 */
const YesDataUtils = {
    /**
     * Formater une date au format fran√ßais
     * @param {Date} date - Date √† formater
     * @returns {string} Date format√©e
     */
    formatDate(date = new Date()) {
        return new Intl.DateTimeFormat('fr-FR', {
            year: 'numeric',
            month: 'long',
            day: 'numeric',
            hour: '2-digit',
            minute: '2-digit'
        }).format(date);
    },

    /**
     * Afficher une notification - CAPTURE AUTOMATIQUE DES ERREURS DANS LE DUMP
     * @param {string} message - Message √† afficher
     * @param {string} type - Type de notification (info, success, warning, error)
     */
    showNotification(message, type = 'info') {
        console.log(`üì¢ ${type.toUpperCase()}: ${message}`);
        
        // CAPTURE AUTOMATIQUE: Si c'est une erreur, l'ajouter au dump avec d√©tails techniques
        if (type === 'error') {
            const timestamp = new Date().toISOString();
            const stackTrace = new Error().stack;
            
            // Ajouter directement au dump avec tous les d√©tails techniques
            ajouterRequeteSQL(
                'üö® NOTIFICATION ERREUR FUGACE',
                `Erreur captur√©e automatiquement depuis notification`,
                `Timestamp: ${timestamp}, Type: ${type}, Stack: ${stackTrace ? stackTrace.substring(0, 300) : 'N/A'}`,
                message
            );
            
            // Log d√©taill√© pour debug
            console.error('üîç ERREUR CAPTUR√âE DANS DUMP:', {
                message: message,
                type: type,
                timestamp: timestamp,
                stack: stackTrace
            });
        }
        
        // Cr√©er l'√©l√©ment de notification
        const notification = document.createElement('div');
        notification.className = `toast toast-${type}`;
        notification.innerHTML = `
            <div class="toast-content">
                <span>${message}</span>
            </div>
        `;
        
        // Ajouter au DOM
        document.body.appendChild(notification);
        
        // Animation d'entr√©e
        setTimeout(() => {
            notification.style.transform = 'translateX(0)';
            notification.style.opacity = '1';
        }, 100);
        
        // Suppression automatique apr√®s 3 secondes (mais reste dans le dump)
        setTimeout(() => {
            notification.style.transform = 'translateX(100%)';
            notification.style.opacity = '0';
            setTimeout(() => {
                if (notification.parentNode) {
                    notification.parentNode.removeChild(notification);
                }
            }, 300);
        }, 3000);
    },

    /**
     * Obtenir l'ic√¥ne pour un type de notification
     * @param {string} type - Type de notification
     * @returns {string} Classe d'ic√¥ne
     */
    getIconForType(type) {
        const icons = {
            'info': 'info-circle',
            'success': 'check-circle',
            'warning': 'exclamation-triangle',
            'error': 'times-circle'
        };
        return icons[type] || 'info-circle';
    },

    /**
     * V√©rifier si l'appareil est mobile
     * @returns {boolean} True si mobile
     */
    isMobile() {
        return window.innerWidth <= 768;
    }
};

/**
 * Initialisation de l'application au chargement du DOM
 */
document.addEventListener('DOMContentLoaded', () => {
    // Cr√©er une instance globale de l'application
    window.yesDataApp = new YesDataApp();
    
    // Exposer les utilitaires globalement
    window.YesDataUtils = YesDataUtils;
    
    // Fonctions de diagnostic accessibles depuis la console
    window.diagnostiquerErreurs = diagnostiquerErreurs;
    
    // Initialiser les variables globales de donn√©es
    window.dumpData = {
        donnees: [],
        headers: [],
        pageActuelle: 1,
        lignesParPage: 10,
        totalPages: 1,
        estOuverte: false
    };
    
    window.resultsData = {
        donnees: [],
        headers: [],
        pageActuelle: 1,
        lignesParPage: 50,
        totalPages: 1
    };
    
    console.log('‚úÖ Variables globales initialis√©es:', {
        dumpData: !!window.dumpData,
        resultsData: !!window.resultsData
    });

    // ========================================
    // PHASE 3 - INITIALISATION DATABASEMANAGER
    // ========================================
    
    console.log('üîÑ Phase 3 - Initialisation DatabaseManager...');
    
    // Fonction d'initialisation asynchrone
    async function initializeDatabaseManager() {
        try {
            await window.DatabaseManager.init();
            console.log('‚úÖ DatabaseManager initialis√© avec succ√®s');
            
            // Tenter la migration depuis localStorage
            await window.DatabaseManager.migrateFromLocalStorage();
            console.log('‚úÖ Migration localStorage termin√©e');
            
            // Afficher les infos de la base
            const info = await window.DatabaseManager.getInfo();
            console.log('üìä Info DatabaseManager:', info);
            
            // Marquer comme pr√™t
            window.DatabaseManager.ready = true;
            
        } catch (error) {
            console.error('‚ùå Erreur lors de l\'initialisation DatabaseManager:', error);
            console.warn('‚ö†Ô∏è Retour au mode localStorage en cas d\'√©chec');
            window.DatabaseManager.ready = false;
        }
    }
    
    // Lancer l'initialisation en arri√®re-plan
    initializeDatabaseManager();

    // ========================================
    // FONCTIONS UTILITAIRES REFACTORIS√âES
    // ========================================

    /**
     * Fonction utilitaire pour extraire la structure des donn√©es
     * Remplace la logique r√©p√©titive dans plusieurs fonctions
     */
    window.extractDataStructure = function(donnees) {
        if (!donnees || Object.keys(donnees).length === 0) {
            return { lignes: [], headers: [] };
        }
        
        // Structure imbriqu√©e
        if (donnees.donnees && donnees.donnees.donnees) {
            return {
                lignes: donnees.donnees.donnees,
                headers: donnees.donnees.headers || []
            };
        }
        
        // Structure directe
        if (Array.isArray(donnees.donnees)) {
            return {
                lignes: donnees.donnees,
                headers: donnees.headers || []
            };
        }
        
        return { lignes: [], headers: [] };
    };

    // V√©rifier automatiquement le nombre de lignes dans la base
    setTimeout(() => {
        const nombreLignes = compterLignes();
        if (nombreLignes > 0) {
            console.log(`üìä BASE DE DONN√âES: ${nombreLignes} lignes charg√©es`);
            console.log(`üîç Pour plus de d√©tails, tapez: yesdata.diagnostic()`);
        } else {
            console.log(`üìä BASE DE DONN√âES: Aucune donn√©e charg√©e`);
            console.log(`üîç Chargez un fichier de ventes WinPharma via la page Chargement`);
        }
    }, 1000);

    // √âcouter les √©v√©nements de changement de page
    document.addEventListener('pageChange', (e) => {
        console.log(`üìÑ Changement de page d√©tect√©:`, e.detail);
    });

    // Initialiser la classe CSS mobile si n√©cessaire
    if (YesDataUtils.isMobile()) {
        document.body.classList.add('mobile-view');
    }
});

/**
 * Gestion des erreurs globales
 */
window.addEventListener('error', (e) => {
    console.error('‚ùå Erreur dans l\'application YesData Frequentation:', e.error);
});

/**
 * Fonctions de gestion des fichiers de ventes WinPharma
 */

/**
 * G√©rer le clic sur le bouton Charger
 */
function gererClicCharger() {
    const chargerBtn = document.getElementById('charger-fichier');
    
    // Si le bouton est dans l'√©tat "loaded", on remet √† gris
    if (chargerBtn && chargerBtn.classList.contains('loaded')) {
        console.log('üîÑ Remise √† z√©ro du bouton Charger');
        reinitialiserEtats();
        YesDataUtils.showNotification('√âtat remis √† z√©ro', 'info');
        return;
    }
    
    // Sinon, lancer le processus de chargement
    chargerFichierWinPharma();
}

/**
 * Fonction principale pour charger un fichier de ventes WinPharma
 * Enchaine toutes les √©tapes : s√©lection, import, validation
 */
function chargerFichierWinPharma() {
    console.log('üöÄ D√©but du processus de chargement fichier WinPharma');
    
    // R√©initialiser les √©tats
    reinitialiserEtats();
    
    // Ouvrir le s√©lecteur de fichier
    const selecteur = document.getElementById('selecteur-fichier');
    if (selecteur) {
        selecteur.click();
        console.log('üìÅ Ouverture du s√©lecteur de fichier WinPharma');
    }
}

/**
 * Gestionnaire de s√©lection de fichier - Version enchain√©e
 * @param {HTMLInputElement} input - √âl√©ment input file
 */
function fichierSelectionne(input) {
    const fichier = input.files[0];
    if (!fichier) {
        reinitialiserEtats();
        return;
    }

    console.log('üìÑ Fichier s√©lectionn√©:', fichier.name);

    // Stocker les informations du fichier
    window.fichierCourant = {
        file: fichier,
        name: fichier.name,
        size: fichier.size,
        type: fichier.type,
        lastModified: new Date(fichier.lastModified)
    };

    // D√©marrer le processus enchain√©
    demarrerProcessusEnchaine();
}

/**
 * D√©marrer le processus enchain√© d'import et validation
 */
async function demarrerProcessusEnchaine() {
    try {
        // Afficher la zone de progression
        afficherProgression();
        
        // Allumer la LED verte du bouton Charger juste avant l'import
        const chargerBtn = document.getElementById('charger-fichier');
        if (chargerBtn) {
            chargerBtn.classList.add('completed');
            definirEtatIndicateur('charger-status', 'completed');
        }
        
        // Petite pause pour voir la LED verte
        await new Promise(resolve => setTimeout(resolve, 500));
        
        // √âTAPE 1: Import des donn√©es
        await etapeImportDonnees();
        
        // √âTAPE 2: Validation et sauvegarde LocalStorage
        await etapeValidation();
        
        // Finalisation
        finaliserProcessus();
        
    } catch (error) {
        console.error('‚ùå Erreur dans le processus:', error);
        YesDataUtils.showNotification(`Erreur: ${error.message}`, 'error');
        
        // Ajouter l'erreur au dump pour qu'elle reste visible
        ajouterErreurAuDump('Erreur de traitement', error.message);
        
        reinitialiserEtats();
    }
}

/**
 * √âtape 1: Import des donn√©es
 */
async function etapeImportDonnees() {
    return new Promise((resolve, reject) => {
        // Mettre √† jour l'interface
        mettreAJourProgression(25, 'Import des donn√©es', 'Lecture du fichier en cours...');
        definirEtatIndicateur('import-status', 'active');
        
        // TRACE IMPORT: D√©but du processus
        const timestampImportDebut = new Date().toISOString();
        ajouterRequeteSQL(
            'üöÄ IMPORT - D√©but du processus',
            `-- D√âBUT IMPORT WinPharma √† ${timestampImportDebut}`,
            `Fichier: ${window.fichierCourant.name}`,
            null
        );
        
        const reader = new FileReader();
        
        reader.onload = async function(e) {
            try {
                console.log('üîç DEBUG - D√©but traitement fichier');
                console.log('üîç DEBUG - Nom fichier:', window.fichierCourant.name);
                console.log('üîç DEBUG - Taille donn√©es:', e.target.result?.byteLength || e.target.result?.length);
                
                // Traitement du fichier
                let donnees;
                const extension = window.fichierCourant.name.split('.').pop().toLowerCase();
                console.log('üîç DEBUG - Extension d√©tect√©e:', extension);
                
                try {
                    switch (extension) {
                        case 'json':
                            console.log('üîç DEBUG - Parsing JSON...');
                            try {
                                donnees = JSON.parse(e.target.result);
                            } catch (jsonError) {
                                ajouterRequeteSQL(
                                    '‚ùå IMPORT - Erreur parsing JSON',
                                    `-- Erreur lors du parsing JSON: ${jsonError.message}`,
                                    `Fichier: ${window.fichierCourant.name}, Position erreur: ${jsonError.message.includes('position') ? jsonError.message : 'N/A'}`,
                                    jsonError.message
                                );
                                throw jsonError;
                            }
                            break;
                        case 'csv':
                            console.log('üîç DEBUG - Parsing CSV...');
                            try {
                                // D√©tecter la taille du fichier pour choisir la m√©thode de traitement
                                const fileSizeBytes = e.target.result?.length || 0;
                                const fileSizeMB = (fileSizeBytes / (1024 * 1024)).toFixed(2);
                                const lineCount = (e.target.result.match(/\n/g) || []).length;
                                
                                console.log(`üìä Analyse fichier CSV: ${fileSizeMB}MB, ~${lineCount} lignes`);
                                
                                // Si le fichier est volumineux (>2MB ou >5000 lignes), utiliser le traitement par paquets
                                if (fileSizeBytes > 2097152 || lineCount > 5000) { // 2MB ou 5000 lignes
                                    console.log('üì¶ Fichier volumineux d√©tect√© - Traitement par paquets activ√©');
                                    
                                    ajouterRequeteSQL(
                                        'üì¶ IMPORT - Traitement par paquets activ√©',
                                        `-- Fichier volumineux: ${fileSizeMB}MB, ~${lineCount} lignes`,
                                        `Traitement par paquets de 1000 lignes pour √©viter les erreurs de quota`,
                                        null
                                    );
                                    
                                    // Mettre √† jour l'interface pour indiquer le traitement par paquets
                                    mettreAJourProgression(15, 'Traitement par paquets', `Fichier volumineux (${fileSizeMB}MB) - Traitement optimis√©`);
                                    
                                    donnees = await parseCSVByBatches(e.target.result, 1000, (progress) => {
                                        // Callback de progression
                                        const progressPercent = 15 + (progress.progress * 0.3); // 15% √† 45%
                                        mettreAJourProgression(
                                            progressPercent, 
                                            `Paquet ${progress.batchIndex}/${progress.totalBatches}`, 
                                            `${progress.totalProcessed}/${progress.totalLines} lignes trait√©es (${progress.progress}%)`
                                        );
                                        
                                        console.log(`üì¶ Paquet ${progress.batchIndex}/${progress.totalBatches}: ${progress.batchSize} lignes, Total: ${progress.totalProcessed}/${progress.totalLines} (${progress.progress}%)`);
                                        
                                        return Promise.resolve();
                                    });
                                    
                                    console.log(`‚úÖ Traitement par paquets termin√©: ${donnees.totalLignes} lignes en ${donnees.totalBatches} paquets`);
                                    
                                } else {
                                    console.log('üìÑ Fichier de taille normale - Traitement standard');
                                    donnees = parseCSV(e.target.result);
                                }
                                
                            } catch (csvError) {
                                ajouterRequeteSQL(
                                    '‚ùå IMPORT - Erreur parsing CSV',
                                    `-- Erreur lors du parsing CSV: ${csvError.message}`,
                                    `Fichier: ${window.fichierCourant.name}, Taille: ${e.target.result?.length || 0} caract√®res`,
                                    csvError.message
                                );
                                throw csvError;
                            }
                            break;
                        case 'xlsx':
                            console.log('üîç DEBUG - Parsing XLSX...');
                            try {
                                donnees = parseXLSX(e.target.result);
                                console.log('üîç DEBUG - R√©sultat parseXLSX:', donnees);
                            } catch (xlsxError) {
                                ajouterRequeteSQL(
                                    '‚ùå IMPORT - Erreur parsing Excel',
                                    `-- Erreur lors du parsing Excel: ${xlsxError.message}`,
                                    `Fichier: ${window.fichierCourant.name}, Taille: ${e.target.result?.byteLength || 0} bytes`,
                                    xlsxError.message
                                );
                                throw xlsxError;
                            }
                            break;
                        default:
                            const formatError = `Format de fichier non support√©: ${extension}`;
                            ajouterRequeteSQL(
                                '‚ùå IMPORT - Format non support√©',
                                `-- Format de fichier non reconnu: .${extension}`,
                                `Fichier: ${window.fichierCourant.name}, Formats support√©s: CSV, XLSX, JSON`,
                                formatError
                            );
                            throw new Error(formatError);
                    }
                } catch (parseError) {
                    // Erreur d√©j√† trac√©e dans les catch sp√©cifiques
                    throw parseError;
                }

                console.log('‚úÖ Import r√©ussi:', donnees);
                console.log('üîç DEBUG - Structure donn√©es:', {
                    hasDonnees: !!donnees?.donnees,
                    isArray: Array.isArray(donnees?.donnees),
                    length: donnees?.donnees?.length || 0,
                    hasHeaders: !!donnees?.headers
                });
                
                // Validation des donn√©es import√©es
                try {
                    if (!donnees) {
                        throw new Error('Aucune donn√©e retourn√©e par le parser');
                    }
                    
                    if (!donnees.donnees || !Array.isArray(donnees.donnees)) {
                        throw new Error('Structure de donn√©es invalide: propri√©t√© "donnees" manquante ou non-array');
                    }
                    
                    if (donnees.donnees.length === 0) {
                        throw new Error('Fichier vide: aucune ligne de donn√©es trouv√©e');
                    }
                    
                    if (!donnees.headers || !Array.isArray(donnees.headers) || donnees.headers.length === 0) {
                        throw new Error('En-t√™tes manquants ou invalides');
                    }
                    
                } catch (validationError) {
                    ajouterRequeteSQL(
                        '‚ùå IMPORT - Validation donn√©es √©chou√©e',
                        `-- Erreur de validation post-parsing: ${validationError.message}`,
                        `Fichier: ${window.fichierCourant.name}, Structure re√ßue: ${JSON.stringify(Object.keys(donnees || {})).substring(0, 100)}`,
                        validationError.message
                    );
                    throw validationError;
                }
                
                // TRACE IMPORT: Parsing r√©ussi
                const nbLignesImport = Array.isArray(donnees?.donnees) ? donnees.donnees.length : 0;
                const formatImport = donnees?.format || extension.toUpperCase();
                ajouterRequeteSQL(
                    'üìä IMPORT - Parsing r√©ussi',
                    `-- Fichier pars√© avec succ√®s: ${formatImport}`,
                    `${nbLignesImport} lignes import√©es`,
                    null
                );
                
                if (donnees?.headers) {
                    ajouterRequeteSQL(
                        'üè∑Ô∏è IMPORT - Colonnes d√©tect√©es',
                        `-- Colonnes: [${donnees.headers.join(', ')}]`,
                        null,
                        null
                    );
                }
                
                // Sauvegarder les donn√©es trait√©es avec v√©rification
                try {
                    if (!window) {
                        throw new Error('Objet window non disponible');
                    }
                    
                    window.donneesImportees = donnees;
                    
                    // V√©rification de la sauvegarde
                    if (!window.donneesImportees || window.donneesImportees !== donnees) {
                        throw new Error('√âchec de la sauvegarde des donn√©es dans window.donneesImportees');
                    }
                    
                } catch (saveError) {
                    ajouterRequeteSQL(
                        '‚ùå IMPORT - Erreur sauvegarde donn√©es',
                        `-- Erreur lors de la sauvegarde en m√©moire: ${saveError.message}`,
                        `Tentative de sauvegarde de ${nbLignesImport} lignes`,
                        saveError.message
                    );
                    throw saveError;
                }
                
                // Import termin√© - pas d'ajout au dump (r√©serv√© aux erreurs uniquement)
                
                // TRACE IMPORT: Finalisation
                const timestampImportFin = new Date().toISOString();
                const dureeImport = new Date(timestampImportFin) - new Date(timestampImportDebut);
                ajouterRequeteSQL(
                    'üéØ IMPORT - Processus termin√©',
                    `-- FIN IMPORT √† ${timestampImportFin} (dur√©e: ${dureeImport}ms)`,
                    `${nbLignesImport} lignes import√©es avec succ√®s`,
                    null
                );
                
                // Marquer l'import comme termin√©
                mettreAJourProgression(50, 'Import termin√©', 'Donn√©es import√©es avec succ√®s');
                definirEtatIndicateur('import-status', 'completed');
                
                setTimeout(() => resolve(donnees), 500);
                
            } catch (error) {
                const errorMsg = `Erreur lors de l'import: ${error.message}`;
                
                // TRACE IMPORT: Erreur d√©taill√©e
                const timestampErreurImport = new Date().toISOString();
                ajouterRequeteSQL(
                    '‚ùå IMPORT - Erreur critique',
                    `-- EXCEPTION IMPORT √† ${timestampErreurImport}`,
                    `Type: ${error.constructor.name}, Message: ${error.message}`,
                    error.message
                );
                
                ajouterRequeteSQL(
                    'üîç IMPORT - Diagnostic erreur',
                    `-- Stack trace: ${error.stack ? error.stack.substring(0, 200) : 'N/A'}`,
                    `Fichier: ${window.fichierCourant ? window.fichierCourant.name : 'N/A'}`,
                    null
                );
                
                // Mise √† jour interface
                definirEtatIndicateur('import-status', 'error');
                mettreAJourProgression(25, 'Erreur d\'import', error.message);
                
                YesDataUtils.showNotification(errorMsg, 'error');
                ajouterErreurAuDump('Import de donn√©es', errorMsg);
                reject(new Error(errorMsg));
            }
        };

        reader.onerror = function(event) {
            const errorMsg = 'Erreur de lecture du fichier';
            
            // TRACE IMPORT: Erreur de lecture
            const timestampErreurLecture = new Date().toISOString();
            ajouterRequeteSQL(
                '‚ùå IMPORT - Erreur lecture fichier',
                `-- ERREUR FileReader √† ${timestampErreurLecture}`,
                `Fichier: ${window.fichierCourant ? window.fichierCourant.name : 'N/A'}, Taille: ${window.fichierCourant ? window.fichierCourant.size : 'N/A'}`,
                errorMsg
            );
            
            ajouterRequeteSQL(
                'üîç IMPORT - D√©tails erreur lecture',
                `-- Event: ${event ? JSON.stringify(event).substring(0, 100) : 'N/A'}`,
                `Type fichier: ${window.fichierCourant ? window.fichierCourant.type : 'N/A'}`,
                null
            );
            
            // Mise √† jour interface
            definirEtatIndicateur('import-status', 'error');
            mettreAJourProgression(10, 'Erreur de lecture', errorMsg);
            
            YesDataUtils.showNotification(errorMsg, 'error');
            ajouterErreurAuDump('Lecture de fichier', errorMsg);
            reject(new Error(errorMsg));
        };

        // Lire le fichier selon son type
        if (window.fichierCourant.name.endsWith('.xlsx')) {
            reader.readAsArrayBuffer(window.fichierCourant.file);
        } else if (window.fichierCourant.type.startsWith('text/') || 
                   window.fichierCourant.name.endsWith('.json') || 
                   window.fichierCourant.name.endsWith('.csv')) {
            reader.readAsText(window.fichierCourant.file);
        } else {
            reader.readAsArrayBuffer(window.fichierCourant.file);
        }
    });
}

/**
 * √âtape 2: Validation et sauvegarde LocalStorage
 */
async function etapeValidation() {
    return new Promise((resolve) => {
        // Mettre √† jour l'interface
        mettreAJourProgression(75, 'Validation des donn√©es', 'Sauvegarde en cours...');
        definirEtatIndicateur('validation-status', 'active');
        
        // EFFACER LE DUMP ET COMMENCER UN NOUVEAU TRA√áAGE
        effacerDumpSQL();
        
        // TRACE 1: D√©but de validation avec contexte complet
        const timestampDebut = new Date().toISOString();
        ajouterRequeteSQL(
            'üîç VALIDATION - D√©but du processus',
            `-- D√âBUT VALIDATION WinPharma √† ${timestampDebut}`,
            `Processus: ${window.fichierCourant ? window.fichierCourant.name : 'Fichier non d√©fini'}`,
            null
        );
        
        // TRACE 1.1: V√©rification des pr√©requis
        const prerequisOK = !!(window.fichierCourant && window.donneesImportees);
        ajouterRequeteSQL(
            '‚úÖ VALIDATION - V√©rification pr√©requis',
            `-- Pr√©requis: fichierCourant=${!!window.fichierCourant}, donneesImportees=${!!window.donneesImportees}`,
            prerequisOK ? 'Tous les pr√©requis sont OK' : 'ERREUR: Pr√©requis manquants',
            prerequisOK ? null : 'Pr√©requis manquants pour la validation'
        );
        
        if (!prerequisOK) {
            const erreurPrerequis = 'Pr√©requis manquants: ' + 
                (!window.fichierCourant ? 'fichierCourant manquant ' : '') +
                (!window.donneesImportees ? 'donneesImportees manquant' : '');
            ajouterRequeteSQL(
                '‚ùå VALIDATION - √âchec pr√©requis',
                `-- ERREUR: ${erreurPrerequis}`,
                null,
                erreurPrerequis
            );
        }
        
        // TRACE 2: Analyse d√©taill√©e du fichier
        let infoFichier;
        try {
            infoFichier = {
                nom: window.fichierCourant.name,
                taille: window.fichierCourant.size,
                type: window.fichierCourant.type,
                extension: window.fichierCourant.name.split('.').pop().toLowerCase(),
                lastModified: window.fichierCourant.file ? new Date(window.fichierCourant.file.lastModified).toISOString() : 'N/A'
            };
            
            ajouterRequeteSQL(
                'üìÅ VALIDATION - Analyse du fichier',
                `-- Fichier: ${infoFichier.nom}`,
                `Taille: ${infoFichier.taille} bytes, Type: ${infoFichier.type}, Extension: ${infoFichier.extension}`,
                null
            );
            
            ajouterRequeteSQL(
                'üìÖ VALIDATION - M√©tadonn√©es fichier',
                `-- Derni√®re modification: ${infoFichier.lastModified}`,
                `Fichier analys√© avec succ√®s`,
                null
            );
            
        } catch (error) {
            ajouterRequeteSQL(
                '‚ùå VALIDATION - Erreur analyse fichier',
                `-- ERREUR lors de l'analyse du fichier: ${error.message}`,
                null,
                error.message
            );
            infoFichier = { nom: 'ERREUR', taille: 0, type: 'ERREUR', extension: 'ERREUR' };
        }
        
        // TRACE 3: Analyse d√©taill√©e des donn√©es import√©es
        let nbLignes, nbColonnes, formatDetecte, donneesValides = true;
        let erreursAnalyse = [];
        
        try {
            // V√©rification de l'existence des donn√©es
            if (!window.donneesImportees) {
                erreursAnalyse.push('window.donneesImportees est null/undefined');
                donneesValides = false;
            }
            
            // Analyse du format
            formatDetecte = window.donneesImportees?.format || 'Format non sp√©cifi√©';
            ajouterRequeteSQL(
                'üîç VALIDATION - D√©tection format',
                `-- Format d√©tect√©: ${formatDetecte}`,
                window.donneesImportees?.separator ? `S√©parateur: ${window.donneesImportees.separator}` : 'S√©parateur non sp√©cifi√©',
                null
            );
            
            // Analyse des lignes
            if (window.donneesImportees?.donnees) {
                if (Array.isArray(window.donneesImportees.donnees)) {
                    nbLignes = window.donneesImportees.donnees.length;
                    ajouterRequeteSQL(
                        'üìä VALIDATION - Analyse lignes',
                        `-- Nombre de lignes: ${nbLignes}`,
                        nbLignes > 0 ? `${nbLignes} lignes de donn√©es trouv√©es` : 'ATTENTION: Aucune ligne de donn√©es',
                        nbLignes === 0 ? 'Fichier vide ou mal pars√©' : null
                    );
                } else {
                    erreursAnalyse.push('donnees n\'est pas un tableau');
                    nbLignes = 0;
                    donneesValides = false;
                }
            } else {
                erreursAnalyse.push('Propri√©t√© donnees manquante');
                nbLignes = 0;
                donneesValides = false;
            }
            
            // Analyse des colonnes
            if (window.donneesImportees?.headers) {
                if (Array.isArray(window.donneesImportees.headers)) {
                    nbColonnes = window.donneesImportees.headers.length;
                    ajouterRequeteSQL(
                        'üè∑Ô∏è VALIDATION - Analyse colonnes',
                        `-- Nombre de colonnes: ${nbColonnes}`,
                        nbColonnes > 0 ? `${nbColonnes} colonnes d√©tect√©es` : 'ATTENTION: Aucune colonne',
                        nbColonnes === 0 ? 'Headers vides' : null
                    );
                    
                    // D√©tail des colonnes
                    const colonnesStr = window.donneesImportees.headers.join(', ');
                    ajouterRequeteSQL(
                        'üìã VALIDATION - Structure des colonnes',
                        `-- Colonnes: [${colonnesStr}]`,
                        `Structure analys√©e avec succ√®s`,
                        null
                    );
                } else {
                    erreursAnalyse.push('headers n\'est pas un tableau');
                    nbColonnes = 0;
                    donneesValides = false;
                }
            } else {
                erreursAnalyse.push('Propri√©t√© headers manquante');
                nbColonnes = 0;
                donneesValides = false;
            }
            
            // R√©sum√© de l'analyse
            ajouterRequeteSQL(
                donneesValides ? '‚úÖ VALIDATION - Analyse donn√©es OK' : '‚ùå VALIDATION - Analyse donn√©es √âCHEC',
                `-- R√©sum√©: Format=${formatDetecte}, Lignes=${nbLignes}, Colonnes=${nbColonnes}`,
                donneesValides ? 'Donn√©es valides pour traitement' : `Erreurs: ${erreursAnalyse.join(', ')}`,
                donneesValides ? null : erreursAnalyse.join('; ')
            );
            
        } catch (error) {
            ajouterRequeteSQL(
                '‚ùå VALIDATION - Erreur analyse donn√©es',
                `-- EXCEPTION lors de l'analyse: ${error.message}`,
                `Stack: ${error.stack?.substring(0, 100)}...`,
                error.message
            );
            donneesValides = false;
            nbLignes = 0;
            nbColonnes = 0;
            formatDetecte = 'ERREUR';
        }
        
        // TRACE 4: Adaptation format WinPharma
        let donneesAdaptees = window.donneesImportees;
        
        if (formatDetecte === 'CSV WinPharma') {
            ajouterRequeteSQL(
                'üîÑ VALIDATION - Adaptation format WinPharma',
                `-- Adaptation des donn√©es au format WinPharma`,
                `Format source d√©tect√©: ${formatDetecte}`,
                null
            );
            
            // Adapter la structure pour WinPharma
            donneesAdaptees = {
                ...window.donneesImportees,
                format: 'CSV WinPharma',
                structure: 'ventes_pharmacie',
                colonnesWinPharma: window.donneesImportees?.headers || [],
                typesDonnees: {
                    'Date': 'date',
                    'Heure': 'time', 
                    'Dossier': 'string',
                    'Type': 'string',
                    'Operateur': 'number',
                    'Client': 'string',
                    'Montant': 'decimal',
                    'Dif./EnCom., EUR': 'decimal'
                }
            };
            
            ajouterRequeteSQL(
                '‚úÖ VALIDATION - Format WinPharma adapt√©',
                `-- Structure adapt√©e pour les ventes de pharmacie`,
                `Colonnes WinPharma: ${donneesAdaptees.colonnesWinPharma.join(', ')}`,
                null
            );
        }
        
        // Pr√©parer les donn√©es pour localStorage avec structure WinPharma
        let donneesAuStockage = {
            fichier: {
                nom: infoFichier.nom,
                taille: infoFichier.taille,
                type: infoFichier.type,
                dateImport: timestampDebut,
                formatSource: 'WinPharma'
            },
            donnees: donneesAdaptees,
            metadata: {
                nombreLignes: nbLignes,
                nombreColonnes: nbColonnes,
                format: formatDetecte,
                structure: 'ventes_pharmacie',
                colonnes: donneesAdaptees?.headers || [],
                colonnesWinPharma: donneesAdaptees?.colonnesWinPharma || [],
                typesDonnees: donneesAdaptees?.typesDonnees || {},
                version: 'v1.0.0-winpharma-frequentation'
            }
        };
        
        try {
            // TRACE 5: Pr√©paration sauvegarde localStorage
            ajouterRequeteSQL(
                'üíæ VALIDATION - Pr√©paration localStorage',
                `-- Pr√©paration des donn√©es pour localStorage (cl√©: winpharma_ventes)`,
                `Donn√©es √† sauvegarder: ${Object.keys(donneesAuStockage).join(', ')}`,
                null
            );
            
            // V√©rification de la disponibilit√© de localStorage
            let localStorageDisponible = false;
            try {
                localStorage.setItem('test_validation', 'test');
                localStorage.removeItem('test_validation');
                localStorageDisponible = true;
                ajouterRequeteSQL(
                    '‚úÖ VALIDATION - Test localStorage',
                    `-- localStorage disponible et fonctionnel`,
                    null,
                    null
                );
            } catch (testError) {
                ajouterRequeteSQL(
                    '‚ùå VALIDATION - Test localStorage √âCHEC',
                    `-- localStorage non disponible: ${testError.message}`,
                    null,
                    testError.message
                );
                throw new Error(`localStorage non disponible: ${testError.message}`);
            }
            
            // S√©rialisation JSON avec v√©rification de taille
            let donneesJson, tailleJson;
            try {
                ajouterRequeteSQL(
                    'üîÑ VALIDATION - S√©rialisation JSON',
                    `-- D√©but s√©rialisation des donn√©es`,
                    `Lignes √† s√©rialiser: ${nbLignes}, Colonnes: ${nbColonnes}`,
                    null
                );
                
                // Gestion sp√©ciale pour les fichiers trait√©s par paquets
                if (donneesAdaptees.processedInBatches) {
                    ajouterRequeteSQL(
                        'üì¶ VALIDATION - Mode paquets d√©tect√©',
                        `-- Fichier trait√© par paquets: ${donneesAdaptees.totalBatches} paquets de ${donneesAdaptees.batchSize} lignes`,
                        `Mode optimis√© pour gros fichiers - Sauvegarde all√©g√©e`,
                        null
                    );
                    
                    // Pour les gros fichiers, on sauvegarde seulement les m√©tadonn√©es et un √©chantillon
                    const echantillonTaille = Math.min(100, donneesAdaptees.donnees.length);
                    const donneesEchantillon = donneesAdaptees.donnees.slice(0, echantillonTaille);
                    
                    donneesAuStockage = {
                        fichier: {
                            nom: infoFichier.nom,
                            taille: infoFichier.taille,
                            type: infoFichier.type,
                            dateImport: timestampDebut,
                            formatSource: 'WinPharma',
                            processedInBatches: true,
                            totalBatches: donneesAdaptees.totalBatches,
                            batchSize: donneesAdaptees.batchSize
                        },
                        donnees: donneesEchantillon, // Seulement un √©chantillon
                        metadata: {
                            nombreLignes: nbLignes,
                            nombreColonnes: nbColonnes,
                            format: formatDetecte,
                            structure: 'ventes_pharmacie',
                            colonnes: donneesAdaptees?.headers || [],
                            colonnesWinPharma: donneesAdaptees?.colonnesWinPharma || [],
                            typesDonnees: donneesAdaptees?.typesDonnees || {},
                            version: 'v1.0.0-winpharma-frequentation',
                            processedInBatches: true,
                            echantillonTaille: echantillonTaille,
                            totalLignesOriginales: donneesAdaptees.totalLignes
                        }
                    };
                    
                    ajouterRequeteSQL(
                        'üíæ VALIDATION - Sauvegarde optimis√©e',
                        `-- Sauvegarde all√©g√©e: m√©tadonn√©es + √©chantillon de ${echantillonTaille} lignes`,
                        `Total original: ${donneesAdaptees.totalLignes} lignes, Sauvegard√©: ${echantillonTaille} lignes`,
                        null
                    );
                    
                } else {
                    // Traitement normal pour les petits fichiers
                    const tailleEstimee = JSON.stringify(donneesAuStockage).length;
                    const tailleMo = (tailleEstimee / (1024 * 1024)).toFixed(2);
                    
                    ajouterRequeteSQL(
                        'üìä VALIDATION - Taille estim√©e',
                        `-- Taille JSON estim√©e: ${tailleEstimee} bytes (${tailleMo} MB)`,
                        tailleEstimee > 10485760 ? 'ATTENTION: Fichier volumineux (>10MB)' : 'Taille acceptable',
                        null
                    );
                    
                    // Limite de s√©curit√© localStorage (g√©n√©ralement 5-10MB)
                    if (tailleEstimee > 10485760) { // 10MB
                        ajouterRequeteSQL(
                            '‚ö†Ô∏è VALIDATION - Fichier volumineux d√©tect√©',
                            `-- ALERTE: Taille ${tailleMo}MB > 10MB (limite localStorage)`,
                            `Risque √©lev√© d'√©chec de sauvegarde - Quota localStorage d√©pass√©`,
                            `Fichier trop volumineux (${tailleMo}MB) - Limite localStorage d√©pass√©e`
                        );
                        
                        ajouterRequeteSQL(
                            'üí° VALIDATION - Actions recommand√©es IMM√âDIATEMENT',
                            `-- SOLUTIONS POUR CONTINUER:`,
                            `1. STOP: Utilisez un fichier plus petit (<5MB)
2. DIVISER: Coupez votre fichier CSV en plusieurs parties
3. FILTRER: Gardez seulement les lignes r√©centes (ex: dernier mois)
4. COLONNES: Supprimez les colonnes non essentielles du CSV
5. TEST: Cr√©ez un fichier de 100-1000 lignes pour tester`,
                            `Solutions concr√®tes pour r√©soudre le probl√®me de taille`
                        );
                        
                        ajouterErreurAuDump('Fichier trop volumineux', `Le fichier WinPharma (${tailleMo}MB) va √©chouer car il d√©passe la limite localStorage (5-10MB max). Utilisez un fichier plus petit ou divisez-le.`);
                    }
                }
                
                donneesJson = JSON.stringify(donneesAuStockage);
                tailleJson = new Blob([donneesJson]).size;
                
                ajouterRequeteSQL(
                    '‚úÖ VALIDATION - S√©rialisation OK',
                    `-- JSON g√©n√©r√©: ${tailleJson} bytes (${(tailleJson / (1024 * 1024)).toFixed(2)} MB)`,
                    `S√©rialisation r√©ussie`,
                    null
                );
                
            } catch (jsonError) {
                const errorMsg = `Erreur s√©rialisation JSON: ${jsonError.message}`;
                ajouterRequeteSQL(
                    '‚ùå VALIDATION - Erreur s√©rialisation JSON',
                    `-- ERREUR JSON.stringify: ${jsonError.message}`,
                    `Type: ${jsonError.constructor.name}, Stack: ${jsonError.stack ? jsonError.stack.substring(0, 100) : 'N/A'}`,
                    jsonError.message
                );
                ajouterErreurAuDump('S√©rialisation JSON', errorMsg);
                YesDataUtils.showNotification(errorMsg, 'error');
                throw new Error(errorMsg);
            }
            
            // Sauvegarde effective
            try {
                ajouterRequeteSQL(
                    'üíæ VALIDATION - Sauvegarde en cours',
                    `-- localStorage.setItem('winpharma_ventes', ...) - ${tailleJson} bytes`,
                    null,
                    null
                );
                
                localStorage.setItem('winpharma_ventes', donneesJson);
                
                // V√©rification de la sauvegarde
                const verification = localStorage.getItem('winpharma_ventes');
                if (verification && verification.length === donneesJson.length) {
                    ajouterRequeteSQL(
                        '‚úÖ VALIDATION - Sauvegarde v√©rifi√©e',
                        `-- Donn√©es sauvegard√©es et v√©rifi√©es (${tailleJson} bytes)`,
                        `Fichier: ${infoFichier.nom}, Lignes: ${nbLignes}, V√©rification: OK`,
                        null
                    );
                } else {
                    throw new Error('V√©rification de sauvegarde √©chou√©e');
                }
                
            } catch (saveError) {
                const errorMsg = `Erreur sauvegarde localStorage: ${saveError.message}`;
                ajouterRequeteSQL(
                    '‚ùå VALIDATION - Erreur sauvegarde localStorage',
                    `-- ERREUR localStorage.setItem: ${saveError.message}`,
                    `Type: ${saveError.constructor.name}, Taille tent√©e: ${tailleJson} bytes`,
                    saveError.message
                );
                
                // Diagnostic sp√©cifique selon le type d'erreur
                if (saveError.message.includes('quota') || saveError.message.includes('storage') || saveError.name === 'QuotaExceededError') {
                    const tailleMB = (tailleJson / (1024 * 1024)).toFixed(2);
                    
                    ajouterRequeteSQL(
                        'üíæ VALIDATION - Diagnostic quota localStorage',
                        `-- QUOTA LOCALSTORAGE D√âPASS√â - Fichier trop volumineux`,
                        `Taille fichier: ${tailleMB}MB, Limite navigateur: 5-10MB max`,
                        `Fichier trop volumineux (${tailleMB}MB) pour localStorage`
                    );
                    
                    ajouterRequeteSQL(
                        'üí° VALIDATION - Solutions recommand√©es',
                        `-- SOLUTIONS POUR FICHIERS VOLUMINEUX:`,
                        `1. Diviser le fichier en plusieurs parties plus petites (<5MB)
2. Utiliser un fichier avec moins de lignes pour les tests
3. Filtrer les donn√©es avant import (garder seulement les colonnes n√©cessaires)
4. Compresser les donn√©es avant stockage`,
                        `Solutions disponibles pour g√©rer les gros fichiers`
                    );
                    
                    ajouterErreurAuDump('Fichier trop volumineux', `Le fichier WinPharma (${tailleMB}MB) d√©passe la limite de stockage du navigateur (5-10MB max). Utilisez un fichier plus petit ou divisez-le en plusieurs parties.`);
                } else {
                    ajouterErreurAuDump('Sauvegarde localStorage', errorMsg);
                }
                
                YesDataUtils.showNotification(errorMsg, 'error');
                throw saveError;
            }
            
            console.log('‚úÖ Donn√©es sauvegard√©es en localStorage');
            
            // TRACE 7: G√©n√©ration requ√™te SQL adapt√©e WinPharma
            try {
                ajouterRequeteSQL(
                    'üîß VALIDATION - D√©but g√©n√©ration SQL WinPharma',
                    `-- G√©n√©ration des requ√™tes pour structure WinPharma`,
                    null,
                    null
                );
                
                // Cr√©er la table WinPharma si n√©cessaire
                const createTableWinPharma = `
                    CREATE TABLE IF NOT EXISTS winpharma_ventes (
                        id INTEGER PRIMARY KEY AUTOINCREMENT,
                        date_vente DATE,
                        heure_vente TIME,
                        dossier VARCHAR(50),
                        type_operation VARCHAR(100),
                        operateur INTEGER,
                        client VARCHAR(255),
                        montant DECIMAL(10,2),
                        difference_encom DECIMAL(10,2),
                        fichier_source VARCHAR(255),
                        date_import DATETIME,
                        validated BOOLEAN DEFAULT FALSE
                    )
                `;
                
                ajouterRequeteSQL(
                    'üèóÔ∏è VALIDATION - Cr√©ation table WinPharma',
                    createTableWinPharma,
                    `Table adapt√©e aux ventes de pharmacie`,
                    null
                );
                
                // Requ√™te de validation adapt√©e
                const requeteValidationTemplate = `UPDATE winpharma_ventes SET validated = ?, metadata = ? WHERE fichier_source = ?`;
                const metadataJson = JSON.stringify(donneesAuStockage.metadata);
            const valeursValidation = [
                true,
                    metadataJson,
                donneesAuStockage.fichier.nom
            ];
                
                ajouterRequeteSQL(
                    'üìã VALIDATION - Template SQL',
                    requeteValidationTemplate,
                    `Template pr√©par√© avec 3 param√®tres`,
                    null
                );
                
                ajouterRequeteSQL(
                    'üìä VALIDATION - Valeurs SQL',
                    `-- Valeur 1 (validated): ${valeursValidation[0]}`,
                    `Valeur 2 (metadata): ${metadataJson.substring(0,100)}${metadataJson.length > 100 ? '...' : ''}`,
                    null
                );
                
                ajouterRequeteSQL(
                    'üìÅ VALIDATION - Fichier cible',
                    `-- Valeur 3 (fichier): "${valeursValidation[2]}"`,
                    `Fichier √† valider dans la base`,
                    null
                );
                
                // Construction de la requ√™te compl√®te
                let requeteValidationComplete;
                try {
                    requeteValidationComplete = construireRequeteSQL(requeteValidationTemplate, valeursValidation);
                    ajouterRequeteSQL(
                        '‚úÖ VALIDATION - Construction SQL OK',
                        `-- Requ√™te construite avec succ√®s`,
                        `Longueur: ${requeteValidationComplete.length} caract√®res`,
                        null
                    );
                } catch (constructError) {
                    ajouterRequeteSQL(
                        '‚ùå VALIDATION - Erreur construction SQL',
                        `-- ERREUR construireRequeteSQL: ${constructError.message}`,
                        null,
                        constructError.message
                    );
                    throw constructError;
                }
                
                // TRACE 8: Requ√™te SQL compl√®te
                ajouterRequeteSQL(
                    'üìù VALIDATION - Requ√™te SQL finale',
                    requeteValidationComplete.substring(0, 500) + (requeteValidationComplete.length > 500 ? '...' : ''),
                    `Validation du fichier ${infoFichier.nom}`,
                    null
                );
                
            } catch (sqlError) {
                const errorMsg = `Erreur g√©n√©ration SQL: ${sqlError.message}`;
                ajouterRequeteSQL(
                    '‚ùå VALIDATION - Erreur g√©n√©ration SQL',
                    `-- EXCEPTION g√©n√©ration SQL: ${sqlError.message}`,
                    `Type: ${sqlError.constructor.name}, Stack: ${sqlError.stack ? sqlError.stack.substring(0, 100) : 'N/A'}`,
                    sqlError.message
                );
                ajouterErreurAuDump('G√©n√©ration SQL', errorMsg);
                YesDataUtils.showNotification(errorMsg, 'error');
                throw sqlError;
            }
            
                            // TRACE 8.5: G√©n√©ration requ√™tes d'insertion WinPharma
                if (donneesAdaptees?.donnees && Array.isArray(donneesAdaptees.donnees)) {
                    ajouterRequeteSQL(
                        'üìä VALIDATION - G√©n√©ration insertions WinPharma',
                        `-- G√©n√©ration de ${donneesAdaptees.donnees.length} requ√™tes INSERT`,
                        null,
                        null
                    );
                    
                    // G√©n√©rer quelques exemples d'insertion
                    const exemplesInsertion = donneesAdaptees.donnees.slice(0, 3);
                    exemplesInsertion.forEach((ligne, index) => {
                        const insertTemplate = `
                            INSERT INTO winpharma_ventes 
                            (date_vente, heure_vente, dossier, type_operation, operateur, client, montant, difference_encom, fichier_source, date_import) 
                            VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
                        `;
                        
                        const valeurs = [
                            ligne.Date || null,
                            ligne.Heure || null,
                            ligne.Dossier || null,
                            ligne.Type || null,
                            ligne.Operateur || null,
                            ligne.Client || null,
                            ligne.Montant || null,
                            ligne['Dif./EnCom., EUR'] || null,
                            donneesAuStockage.fichier.nom,
                            timestampDebut
                        ];
                        
                        ajouterRequeteSQL(
                            `üíæ VALIDATION - Exemple insertion ${index + 1}`,
                            insertTemplate.trim(),
                            `Valeurs: [${valeurs.map(v => v ? `"${v}"` : 'NULL').join(', ')}]`,
                            null
                        );
                    });
                    
                    if (donneesAdaptees.donnees.length > 3) {
                        ajouterRequeteSQL(
                            'üìä VALIDATION - Insertions restantes',
                            `-- ... et ${donneesAdaptees.donnees.length - 3} autres requ√™tes INSERT similaires`,
                            `Total: ${donneesAdaptees.donnees.length} lignes √† ins√©rer`,
                            null
                        );
                    }
                }
                
                                // Validation termin√©e - pas d'ajout au dump (r√©serv√© aux erreurs uniquement)
            
            // TRACE 10: Finalisation
            setTimeout(() => {
                const timestampFin = new Date().toISOString();
                const duree = new Date(timestampFin) - new Date(timestampDebut);
                
                ajouterRequeteSQL(
                    'üéØ VALIDATION - Finalisation',
                    `-- D√©but finalisation du processus`,
                    null,
                    null
                );
                
                // Mise √† jour de l'interface
                try {
                definirEtatIndicateur('validation-status', 'completed');
                    ajouterRequeteSQL(
                        '‚úÖ VALIDATION - LED mise √† jour',
                        `-- LED validation pass√©e en 'completed'`,
                        null,
                        null
                    );
                } catch (ledError) {
                    ajouterRequeteSQL(
                        '‚ùå VALIDATION - Erreur LED',
                        `-- ERREUR mise √† jour LED: ${ledError.message}`,
                        null,
                        ledError.message
                    );
                }
                
                // Mise √† jour de la progression
                try {
                mettreAJourProgression(100, 'Validation termin√©e', 'Donn√©es sauvegard√©es avec succ√®s');
                    ajouterRequeteSQL(
                        '‚úÖ VALIDATION - Progression mise √† jour',
                        `-- Progression mise √† 100%`,
                        null,
                        null
                    );
                } catch (progressError) {
                    ajouterRequeteSQL(
                        '‚ùå VALIDATION - Erreur progression',
                        `-- ERREUR mise √† jour progression: ${progressError.message}`,
                        null,
                        progressError.message
                    );
                }
                
                // R√©sum√© final WinPharma
                ajouterRequeteSQL(
                    'üéØ VALIDATION - Processus WinPharma termin√© avec succ√®s',
                    `-- FIN VALIDATION WINPHARMA √† ${timestampFin} (dur√©e: ${duree}ms)`,
                    `Fichier: ${infoFichier.nom}, Lignes: ${nbLignes}, Taille: ${tailleJson} bytes, Structure: ventes_pharmacie`,
                    null
                );
                
                // Statistiques WinPharma
                if (donneesAdaptees?.donnees) {
                    const stats = {
                        totalVentes: donneesAdaptees.donnees.length,
                        montantTotal: donneesAdaptees.donnees.reduce((sum, ligne) => {
                            const montant = parseFloat(ligne.Montant) || 0;
                            return sum + montant;
                        }, 0),
                        operateursUniques: [...new Set(donneesAdaptees.donnees.map(l => l.Operateur).filter(Boolean))].length,
                        typesOperations: [...new Set(donneesAdaptees.donnees.map(l => l.Type).filter(Boolean))].length
                    };
                    
                    ajouterRequeteSQL(
                        'üìä VALIDATION - Statistiques WinPharma',
                        `-- Statistiques des ventes de pharmacie`,
                        `Ventes: ${stats.totalVentes}, Montant total: ${stats.montantTotal.toFixed(2)}‚Ç¨, Op√©rateurs: ${stats.operateursUniques}, Types: ${stats.typesOperations}`,
                        null
                    );
                }
                
                resolve();
            }, 500);
            
        } catch (error) {
            // TRACE 11: Gestion d'erreur d√©taill√©e
            const timestampErreur = new Date().toISOString();
            const dureeAvantErreur = new Date(timestampErreur) - new Date(timestampDebut);
            
            ajouterRequeteSQL(
                '‚ùå VALIDATION - ERREUR CRITIQUE',
                `-- EXCEPTION √† ${timestampErreur} (apr√®s ${dureeAvantErreur}ms)`,
                `Type: ${error.constructor.name}, Message: ${error.message}`,
                null
            );
            
            // D√©tails de l'erreur
            ajouterRequeteSQL(
                'üîç VALIDATION - D√©tails erreur',
                `-- Message: ${error.message}`,
                `Stack: ${error.stack ? error.stack.substring(0, 200) + '...' : 'Stack non disponible'}`,
                error.message
            );
            
            // √âtat du syst√®me au moment de l'erreur
            ajouterRequeteSQL(
                'üìä VALIDATION - √âtat syst√®me',
                `-- localStorage disponible: ${typeof Storage !== 'undefined'}`,
                `window.fichierCourant: ${!!window.fichierCourant}, window.donneesImportees: ${!!window.donneesImportees}`,
                null
            );
            
            // Mise √† jour de l'interface en cas d'erreur
            try {
                definirEtatIndicateur('validation-status', 'error');
                mettreAJourProgression(75, 'Erreur de validation', error.message);
                ajouterRequeteSQL(
                    '‚ö†Ô∏è VALIDATION - Interface mise √† jour',
                    `-- LED pass√©e en erreur, progression arr√™t√©e`,
                    null,
                    null
                );
            } catch (uiError) {
                ajouterRequeteSQL(
                    '‚ùå VALIDATION - Erreur interface',
                    `-- Impossible de mettre √† jour l'interface: ${uiError.message}`,
                    null,
                    uiError.message
                );
            }
            
            // Notifications
            console.error('‚ùå Erreur validation compl√®te:', error);
            YesDataUtils.showNotification(`Erreur de validation: ${error.message}`, 'error');
            ajouterErreurAuDump('Validation compl√®te', error.message);
            
            // R√©sum√© d'√©chec WinPharma
            ajouterRequeteSQL(
                'üí• VALIDATION - Processus WinPharma √©chou√©',
                `-- √âCHEC VALIDATION WINPHARMA √† ${timestampErreur}`,
                `Dur√©e avant √©chec: ${dureeAvantErreur}ms, Format: ${formatDetecte}, Structure: ventes_pharmacie`,
                error.message
            );
            
            // Diagnostic sp√©cifique WinPharma
            if (formatDetecte === 'CSV WinPharma') {
                ajouterRequeteSQL(
                    'üîç VALIDATION - Diagnostic WinPharma',
                    `-- Diagnostic sp√©cifique au format WinPharma`,
                    `Colonnes attendues: Date, Heure, Dossier, Type, Operateur, Client, Montant`,
                    null
                );
            }
            
            resolve(); // On continue m√™me si la validation √©choue
        }
    });
}

/**
 * Finaliser le processus
 */
function finaliserProcessus() {
    setTimeout(() => {
        masquerProgression();
        YesDataUtils.showNotification(`Fichier ${window.fichierCourant.name} trait√© avec succ√®s`, 'success');
        
        // Mettre le bouton dans l'√©tat "loaded" (bleu avec LED verte)
        const chargerBtn = document.getElementById('charger-fichier');
        if (chargerBtn) {
            // Retirer l'√©tat "completed" temporaire et ajouter "loaded"
            chargerBtn.classList.remove('completed');
            chargerBtn.classList.add('loaded');
            definirEtatIndicateur('charger-status', 'completed'); // LED verte
        }
        
        // Initialiser la section Dump avec les donn√©es import√©es
        console.log('üö® CHARGEMENT - V√©rification window.donneesImportees:', !!window.donneesImportees);
        console.log('üö® CHARGEMENT - window.donneesImportees:', window.donneesImportees);
        
        if (window.donneesImportees) {
            console.log('üö® CHARGEMENT - Appel initialiserDump avec:', window.donneesImportees);
            initialiserDump(window.donneesImportees);
            
            // Afficher les informations Excel si disponibles
            if (window.donneesImportees.ongletUtilise) {
                YesDataUtils.showNotification(`Donn√©es charg√©es depuis l'onglet ${window.donneesImportees.ongletUtilise}: ${window.donneesImportees.feuilleActive}`, 'info');
            }
            if (window.donneesImportees.dateExtrait) {
                YesDataUtils.showNotification(`Date extraite: ${window.donneesImportees.dateExtrait}`, 'info');
            }
        }
    }, 1000);
}

/**
 * Effacer les donn√©es de la base
 */
function effacerDonnees() {
    console.log('üóëÔ∏è D√âBUT - Fonction effacerDonnees() appel√©e [REFACTORIS√âE]');
    
    // V√©rifier l'√©tat avec StorageManager
    const stats = StorageManager.getStats();
    console.log('üîç AVANT EFFACEMENT:', stats);
    
    if (!stats.donnees.exists && !stats.summary.exists) {
        YesDataUtils.showNotification('Aucune donn√©e √† effacer', 'info');
        console.log('‚ÑπÔ∏è Aucune donn√©e √† effacer');
        return;
    }
    
    // Confirmer l'action
    if (!confirm('‚ö†Ô∏è √ätes-vous s√ªr de vouloir effacer toutes les donn√©es de la base ?\n\nCette action est irr√©versible.')) {
        console.log('‚ùå Effacement annul√© par l\'utilisateur');
        return;
    }
    
    console.log('üóëÔ∏è Effacement des donn√©es confirm√© par l\'utilisateur');
    
    try {
        // Effacement avec StorageManager
        const report = StorageManager.clearAll();
        console.log('üìä Rapport d\'effacement:', report);
        
        if (report.success) {
            // Effacer les dumps en m√©moire
            console.log('üóëÔ∏è Effacement des dumps en m√©moire...');
            if (window.insertionDump) {
                window.insertionDump = [];
                mettreAJourDumpInsertion();
            }
            if (window.importDump) {
                window.importDump = [];
                mettreAJourImportDump();
            }
            
            // R√©initialiser tous les √©tats de l'interface
            console.log('üîÑ R√©initialisation des √©tats de l\'interface...');
            reinitialiserEtats();
            
            // Vider le dump si affich√©
            if (window.dumpData) {
                console.log('üóëÔ∏è R√©initialisation du dump...');
                window.dumpData.donnees = [];
                window.dumpData.headers = [];
                window.dumpData.pageActuelle = 1;
                
                // Mettre √† jour l'affichage du dump
                const overviewContent = document.getElementById('overview-content');
                if (overviewContent) {
                    overviewContent.innerHTML = '<p class="dump-empty">Aucune donn√©e √† afficher</p>';
                }
            }
            
            // V√©rification finale avec StorageManager
            const statsApres = StorageManager.getStats();
            console.log('üîç APR√àS EFFACEMENT:', statsApres);
            
            // Notification de succ√®s
            YesDataUtils.showNotification('Donn√©es effac√©es avec succ√®s', 'success');
            console.log('‚úÖ SUCC√àS - Toutes les donn√©es ont √©t√© effac√©es');
            
        } else {
            throw new Error('√âchec de l\'effacement des donn√©es');
        }
        
    } catch (error) {
        console.error('‚ùå ERREUR lors de l\'effacement:', error);
        console.error('‚ùå Stack trace:', error.stack);
        YesDataUtils.showNotification('Erreur lors de l\'effacement des donn√©es', 'error');
    }
}

/**
 * Formater la taille du fichier
 * @param {number} bytes - Taille en octets
 * @returns {string} Taille format√©e
 */
function formatTailleFichier(bytes) {
    if (bytes === 0) return '0 octets';
    
    const k = 1024;
    const tailles = ['octets', 'Ko', 'Mo', 'Go'];
    const i = Math.floor(Math.log(bytes) / Math.log(k));
    
    return parseFloat((bytes / Math.pow(k, i)).toFixed(2)) + ' ' + tailles[i];
}

/**
 * Parser CSV simple (pour d√©mo)
 * @param {string} csvText - Contenu CSV
 * @returns {Array} Donn√©es pars√©es
 */
function parseCSV(csvText) {
    console.log('üîç DEBUG parseCSV - D√©but parsing CSV');
    
    const lignes = csvText.split('\n');
    console.log(`üîç DEBUG parseCSV - Nombre de lignes: ${lignes.length}`);
    
    if (lignes.length === 0) {
        throw new Error('Fichier CSV vide');
    }
    
    // Utiliser point-virgule comme s√©parateur pour le format WinPharma
    const headersRaw = lignes[0].split(';');
    console.log('üîç DEBUG parseCSV - Headers bruts:', headersRaw);
    
    // Mapping des colonnes selon les sp√©cifications
    const columnMapping = {
        'Date': 'Date',
        'Heure': 'Heure', 
        'Dossier': 'Dossier',
        'Type': 'Type',
        'Op√©r.': 'Operateur',
        'OpÔøΩr.': 'Operateur', // Support pour l'encodage d√©faillant
        'Client': 'Client',
        'Mont., EUR': 'Montant',
        'R√©gl√©, EUR': null, // Colonne ignor√©e
        'RÔøΩglÔøΩ, EUR': null, // Support pour l'encodage d√©faillant - colonne ignor√©e
        'Dif./EnCom., EUR': 'Dif./EnCom., EUR'
    };
    
    // Cr√©er les headers finaux en appliquant le mapping
    const headers = [];
    const headerIndexes = [];
    
    headersRaw.forEach((header, index) => {
        const cleanHeader = header.trim().replace(/"/g, ''); // Nettoyer les guillemets
        const mappedHeader = columnMapping[cleanHeader];
        
        if (mappedHeader !== null) { // null = colonne ignor√©e
            headers.push(mappedHeader || cleanHeader);
            headerIndexes.push(index);
        }
    });
    
    console.log('üîç DEBUG parseCSV - Headers finaux:', headers);
    console.log('üîç DEBUG parseCSV - Index des colonnes utilis√©es:', headerIndexes);
    
    const donnees = [];
    
    for (let i = 1; i < lignes.length; i++) {
        const ligne = lignes[i].trim();
        if (ligne) {
            // Parser la ligne en tenant compte des guillemets
            const valeurs = parseCSVLine(ligne);
            
            if (valeurs.length > 0) {
            const objet = {};
                
                headerIndexes.forEach((originalIndex, newIndex) => {
                    const header = headers[newIndex];
                    let valeur = valeurs[originalIndex]?.trim() || '';
                    
                    // Nettoyer les guillemets
                    valeur = valeur.replace(/^"|"$/g, '');
                    
                    // Traitement sp√©cial pour les montants (remplacer virgule par point)
                    if (header === 'Montant' || header.includes('EUR')) {
                        valeur = valeur.replace(',', '.');
                    }
                    
                    objet[header] = valeur;
                });
                
            donnees.push(objet);
            }
        }
    }
    
    console.log(`‚úÖ parseCSV - ${donnees.length} lignes pars√©es avec succ√®s`);
    console.log('üîç DEBUG parseCSV - Exemple premi√®re ligne:', donnees[0]);
    
    return { 
        headers, 
        donnees, 
        totalLignes: donnees.length,
        format: 'CSV WinPharma',
        separator: ';'
    };
}

/**
 * Parse une ligne CSV en tenant compte des guillemets et des points-virgules
 * @param {string} ligne - Ligne CSV √† parser
 * @returns {Array} Tableau des valeurs
 */
function parseCSVLine(ligne) {
    const valeurs = [];
    let valeurCourante = '';
    let dansGuillemets = false;
    
    for (let i = 0; i < ligne.length; i++) {
        const char = ligne[i];
        
        if (char === '"') {
            dansGuillemets = !dansGuillemets;
            valeurCourante += char;
        } else if (char === ';' && !dansGuillemets) {
            valeurs.push(valeurCourante);
            valeurCourante = '';
        } else {
            valeurCourante += char;
        }
    }
    
    // Ajouter la derni√®re valeur
    if (valeurCourante || valeurs.length > 0) {
        valeurs.push(valeurCourante);
    }
    
    return valeurs;
}

/**
 * Parser CSV par paquets pour g√©rer les gros fichiers
 * @param {string} csvText - Contenu du fichier CSV
 * @param {number} batchSize - Taille des paquets (d√©faut: 1000)
 * @param {Function} onBatchProcessed - Callback appel√© pour chaque paquet trait√©
 * @returns {Promise<Object>} Donn√©es pars√©es avec m√©tadonn√©es
 */
async function parseCSVByBatches(csvText, batchSize = 1000, onBatchProcessed = null) {
    console.log('üîç DEBUG parseCSVByBatches - D√©but parsing CSV par paquets');
    
    const lignes = csvText.split('\n');
    console.log(`üîç DEBUG parseCSVByBatches - Nombre total de lignes: ${lignes.length}`);
    
    if (lignes.length === 0) {
        throw new Error('Fichier CSV vide');
    }
    
    // Traiter les headers (m√™me logique que parseCSV)
    const headersRaw = lignes[0].split(';');
    console.log('üîç DEBUG parseCSVByBatches - Headers bruts:', headersRaw);
    
    const columnMapping = {
        'Date': 'Date',
        'Heure': 'Heure', 
        'Dossier': 'Dossier',
        'Type': 'Type',
        'Op√©r.': 'Operateur',
        'OpÔøΩr.': 'Operateur',
        'Client': 'Client',
        'Mont., EUR': 'Montant',
        'R√©gl√©, EUR': null,
        'RÔøΩglÔøΩ, EUR': null,
        'Dif./EnCom., EUR': 'Dif./EnCom., EUR'
    };
    
    const headers = [];
    const headerIndexes = [];
    
    headersRaw.forEach((header, index) => {
        const cleanHeader = header.trim().replace(/"/g, '');
        const mappedHeader = columnMapping[cleanHeader];
        
        if (mappedHeader !== null) {
            headers.push(mappedHeader || cleanHeader);
            headerIndexes.push(index);
        }
    });
    
    console.log('üîç DEBUG parseCSVByBatches - Headers finaux:', headers);
    
    // Traitement par paquets
    const totalDataLines = lignes.length - 1; // Exclure la ligne d'en-t√™te
    const totalBatches = Math.ceil(totalDataLines / batchSize);
    let totalProcessed = 0;
    let allData = [];
    
    console.log(`üì¶ Traitement par paquets: ${totalDataLines} lignes en ${totalBatches} paquets de ${batchSize}`);
    
    for (let batchIndex = 0; batchIndex < totalBatches; batchIndex++) {
        const startLine = 1 + (batchIndex * batchSize); // +1 pour ignorer les headers
        const endLine = Math.min(startLine + batchSize, lignes.length);
        
        console.log(`üì¶ Traitement paquet ${batchIndex + 1}/${totalBatches}: lignes ${startLine} √† ${endLine - 1}`);
        
        const batchData = [];
        
        for (let i = startLine; i < endLine; i++) {
            const ligne = lignes[i].trim();
            if (ligne) {
                const valeurs = parseCSVLine(ligne);
                
                if (valeurs.length > 0) {
                    const objet = {};
                    
                    headerIndexes.forEach((originalIndex, newIndex) => {
                        const header = headers[newIndex];
                        let valeur = valeurs[originalIndex]?.trim() || '';
                        
                        valeur = valeur.replace(/^"|"$/g, '');
                        
                        if (header === 'Montant' || header.includes('EUR')) {
                            valeur = valeur.replace(',', '.');
                        }
                        
                        objet[header] = valeur;
                    });
                    
                    batchData.push(objet);
                }
            }
        }
        
        totalProcessed += batchData.length;
        allData = allData.concat(batchData);
        
        // Callback pour chaque paquet trait√©
        if (onBatchProcessed) {
            await onBatchProcessed({
                batchIndex: batchIndex + 1,
                totalBatches,
                batchSize: batchData.length,
                totalProcessed,
                totalLines: totalDataLines,
                progress: Math.round((totalProcessed / totalDataLines) * 100)
            });
        }
        
        // Petite pause pour ne pas bloquer l'interface
        await new Promise(resolve => setTimeout(resolve, 10));
    }
    
    console.log(`‚úÖ parseCSVByBatches - ${totalProcessed} lignes pars√©es en ${totalBatches} paquets`);
    
    return { 
        headers, 
        donnees: allData, 
        totalLignes: totalProcessed,
        format: 'CSV WinPharma',
        separator: ';',
        processedInBatches: true,
        batchSize,
        totalBatches
    };
}

/**
 * Parser Excel (.xlsx) en utilisant SheetJS
 * @param {ArrayBuffer} arrayBuffer - Contenu du fichier Excel
 * @returns {Object} Donn√©es pars√©es
 */
function parseXLSX(arrayBuffer) {
    try {
        console.log('üîç DEBUG parseXLSX - D√©but parsing Excel');
        console.log('üîç DEBUG parseXLSX - Type arrayBuffer:', typeof arrayBuffer);
        console.log('üîç DEBUG parseXLSX - Taille arrayBuffer:', arrayBuffer?.byteLength);
        
        // Lire le fichier Excel avec SheetJS
        const workbook = XLSX.read(arrayBuffer, { type: 'array' });
        console.log('üîç DEBUG parseXLSX - Workbook cr√©√©:', !!workbook);
        
        console.log(`üìä Feuilles Excel disponibles: ${workbook.SheetNames.join(', ')}`);
        
        // Prendre l'onglet 2 si disponible, sinon l'onglet 1
        let targetSheetIndex = 1; // Onglet 2 (index 1)
        let targetSheetName;
        
        if (workbook.SheetNames.length > 1) {
            targetSheetName = workbook.SheetNames[targetSheetIndex];
            console.log(`üìã Utilisation de l'onglet 2: ${targetSheetName}`);
        } else {
            targetSheetIndex = 0;
            targetSheetName = workbook.SheetNames[targetSheetIndex];
            console.log(`üìã Utilisation de l'onglet 1: ${targetSheetName} (onglet 2 non disponible)`);
        }
        
        const worksheet = workbook.Sheets[targetSheetName];
        
        // Extraire une date du nom de l'onglet avec RegexPatterns
        const dateExtrait = RegexPatterns.extractExcelDate(targetSheetName);
        if (dateExtrait) {
            console.log(`üìÖ Date extraite du nom de l'onglet: ${dateExtrait}`);
        }
        
        // Convertir en JSON
        const jsonData = XLSX.utils.sheet_to_json(worksheet, { header: 1 });
        
        if (jsonData.length === 0) {
            return { 
                headers: [], 
                donnees: [], 
                totalLignes: 0, 
                feuilles: workbook.SheetNames,
                feuilleActive: targetSheetName,
                dateExtrait: dateExtrait
            };
        }
        
        // Premi√®re ligne = headers
        const headersOriginaux = jsonData[0] || [];
        console.log('üìã Headers originaux:', headersOriginaux);
        
        // D√©finir les colonnes √† conserver avec leurs variations possibles
        const colonnesRequises = {
            'D*': {
                nouveauNom: 'Dx',
                variations: ['D*', 'D', 'Dx', 'Application ID', 'ID']
            },
            'App. Name': {
                nouveauNom: 'App Appli',
                variations: ['App. Name', 'App Name', 'Application Name', 'Appli Name', 'Name']
            },
            'App. Code': {
                nouveauNom: 'App Code',
                variations: ['App. Code', 'App Code', 'Application Code', 'Code', 'App_Code']
            },
            'Operator/Department': {
                nouveauNom: 'Operator/Department',
                variations: ['Operator/Department', 'Operator', 'Department', 'Owner', 'Team']
            },
            'Business criticality': {
                nouveauNom: 'Business criticality',
                variations: ['Business criticality', 'Business Criticality', 'Criticality', 'Critical', 'Priority']
            },
            'Functional monitoring (BSM)': {
                nouveauNom: 'Functional monitoring (BSM)',
                variations: ['Functional monitoring (BSM)', 'Functional monitoring', 'Functional Monitoring', 'Monitoring', 'BSM', 'Monitored']
            },
            'In HCC': {
                nouveauNom: 'In HCC',
                variations: ['In HCC', 'HCC', 'In_HCC', 'HCC Status']
            },
            'HCC eligibility': {
                nouveauNom: 'HCC eligibility',
                variations: ['HCC eligibility', 'HCC Eligibility', 'HCC_eligibility', 'Eligible HCC', 'HCC Eligible', 'HCC eligibility AV (Added Value)', 'HCC eligibility AV']
            }
        };
        
        console.log('üîç Recherche des colonnes dans les headers:', headersOriginaux);
        
        // Trouver les indices des colonnes requises avec recherche flexible
        const indicesColonnes = {};
        const headersFiltr√©s = [];
        
        Object.keys(colonnesRequises).forEach(clePrincipale => {
            const config = colonnesRequises[clePrincipale];
            let indexTrouve = -1;
            let nomTrouve = '';
            
            // Essayer chaque variation
            for (const variation of config.variations) {
                const index = headersOriginaux.findIndex(header => 
                    header && header.toString().trim().toLowerCase() === variation.toLowerCase()
                );
                if (index !== -1) {
                    indexTrouve = index;
                    nomTrouve = headersOriginaux[index];
                    break;
                }
            }
            
            if (indexTrouve !== -1) {
                indicesColonnes[clePrincipale] = indexTrouve;
                headersFiltr√©s.push(config.nouveauNom);
                console.log(`‚úÖ Colonne trouv√©e: "${nomTrouve}" -> "${config.nouveauNom}" (index ${indexTrouve})`);
            } else {
                console.warn(`‚ö†Ô∏è Colonne non trouv√©e pour "${clePrincipale}". Variations cherch√©es:`, config.variations);
                console.warn(`‚ö†Ô∏è Headers disponibles:`, headersOriginaux);
            }
        });
        
        // S'assurer que tous les headers requis sont pr√©sents, m√™me si les colonnes sont manquantes
        const tousLesHeaders = Object.keys(colonnesRequises).map(cle => colonnesRequises[cle].nouveauNom);
        const headersFinaux = [...new Set([...headersFiltr√©s, ...tousLesHeaders])];
        
        console.log('üìã Headers filtr√©s:', headersFiltr√©s);
        console.log('üìã Headers finaux (avec colonnes manquantes):', headersFinaux);
        console.log('üìã Indices des colonnes:', indicesColonnes);
        
        const donnees = [];
        
        // Convertir les donn√©es en objets avec seulement les colonnes requises
        for (let i = 1; i < jsonData.length; i++) {
            const ligne = jsonData[i];
            if (ligne && ligne.some(cell => cell !== undefined && cell !== '')) {
                const objet = {};
                let hasData = false;
                
                Object.keys(colonnesRequises).forEach(clePrincipale => {
                    const config = colonnesRequises[clePrincipale];
                    const index = indicesColonnes[clePrincipale];
                    
                    if (index !== undefined) {
                        const valeur = ligne[index] || '';
                        objet[config.nouveauNom] = valeur;
                        if (valeur !== '') hasData = true;
                    } else {
                        // Ajouter la colonne avec une valeur par d√©faut si elle n'existe pas
                        objet[config.nouveauNom] = '';
                        console.log(`‚ö†Ô∏è Colonne "${config.nouveauNom}" ajout√©e avec valeur vide (colonne manquante dans Excel)`);
                    }
                });
                
                // N'ajouter la ligne que si elle contient des donn√©es
                if (hasData) {
                    donnees.push(objet);
                }
            }
        }
        
        console.log(`üìä Donn√©es filtr√©es: ${donnees.length} lignes avec ${headersFiltr√©s.length} colonnes`);
        
        const result = {
            headers: headersFinaux,
            donnees,
            totalLignes: donnees.length,
            feuilles: workbook.SheetNames,
            feuilleActive: targetSheetName,
            ongletUtilise: targetSheetIndex + 1,
            dateExtrait: dateExtrait
        };
        
        console.log('üîç DEBUG parseXLSX - R√©sultat final:', result);
        console.log('üîç DEBUG parseXLSX - Nombre de donn√©es retourn√©es:', result.donnees?.length);
        
        return result;
        
    } catch (error) {
        console.error('‚ùå Erreur lors du parsing Excel:', error);
        throw new Error(`Erreur lors de la lecture du fichier Excel: ${error.message}`);
    }
}

/**
 * Fonctions utilitaires pour les √©tats et la progression
 */

/**
 * R√©initialiser tous les √©tats
 */
function reinitialiserEtats() {
    console.log('üßπ D√âBUT - R√©initialisation des √©tats');
    
    // R√©initialiser les indicateurs d'√©tat
    console.log('üîÑ R√©initialisation des indicateurs d\'√©tat...');
    definirEtatIndicateur('charger-status', 'inactive');
    definirEtatIndicateur('import-status', 'inactive');
    definirEtatIndicateur('validation-status', 'inactive');
    
    // R√©initialiser le bouton principal
    console.log('üîÑ R√©initialisation du bouton charger...');
    const chargerBtn = document.getElementById('charger-fichier');
    if (chargerBtn) {
        chargerBtn.classList.remove('completed', 'active', 'loaded');
        console.log('‚úÖ Bouton charger r√©initialis√©');
    } else {
        console.log('‚ö†Ô∏è Bouton charger non trouv√©');
    }
    
    // Masquer la progression
    console.log('üîÑ Masquage de la progression...');
    masquerProgression();
    
    // Masquer la section Overview
    console.log('üîÑ Masquage de la section Overview...');
    const overviewSection = document.getElementById('overview-section');
    if (overviewSection) {
        overviewSection.style.display = 'none';
        console.log('‚úÖ Section Overview masqu√©e');
    } else {
        console.log('‚ö†Ô∏è Section Overview non trouv√©e');
    }
    
    // Masquer la section Dump d'insertion
    console.log('üîÑ Masquage de la section Dump d\'insertion...');
    const insertionDumpSection = document.getElementById('insertion-dump-section');
    if (insertionDumpSection) {
        insertionDumpSection.style.display = 'none';
        console.log('‚úÖ Section Dump d\'insertion masqu√©e');
    } else {
        console.log('‚ö†Ô∏è Section Dump d\'insertion non trouv√©e');
    }
    
    // Masquer la section Dump d'import/validation
    console.log('üîÑ Masquage de la section Dump d\'import/validation...');
    const importDumpSection = document.getElementById('import-dump-section');
    if (importDumpSection) {
        importDumpSection.style.display = 'none';
        console.log('‚úÖ Section Dump d\'import/validation masqu√©e');
    } else {
        console.log('‚ö†Ô∏è Section Dump d\'import/validation non trouv√©e');
    }
    
    // R√©initialiser les donn√©es Dump
    console.log('üîÑ R√©initialisation des donn√©es Dump...');
    window.dumpData = {
        donnees: [],
        headers: [],
        pageActuelle: 1,
        lignesParPage: 10,
        totalPages: 1,
        estOuverte: false
    };
    console.log('‚úÖ Donn√©es Dump r√©initialis√©es');
    
    // R√©initialiser les donn√©es de r√©sultats
    window.resultsData = {
        donnees: [],
        headers: [],
        pageActuelle: 1,
        lignesParPage: 50,
        totalPages: 1
    };
    
    // R√©initialiser le dump d'insertion
    console.log('üîÑ R√©initialisation du dump d\'insertion...');
    window.insertionDump = [];
    mettreAJourDumpInsertion();
    console.log('‚úÖ Dump d\'insertion r√©initialis√©');
    
    // R√©initialiser le dump d'import/validation
    console.log('üîÑ R√©initialisation du dump d\'import/validation...');
    window.importDump = [];
    mettreAJourImportDump();
    console.log('‚úÖ Dump d\'import/validation r√©initialis√©');
    
    // R√©initialiser le s√©lecteur
    console.log('üîÑ R√©initialisation du s√©lecteur de fichier...');
    const selecteur = document.getElementById('selecteur-fichier');
    if (selecteur) {
        selecteur.value = '';
        console.log('‚úÖ S√©lecteur de fichier r√©initialis√©');
    } else {
        console.log('‚ö†Ô∏è S√©lecteur de fichier non trouv√©');
    }
    
    // Nettoyer les donn√©es globales
    console.log('üîÑ Nettoyage des donn√©es globales...');
    delete window.fichierCourant;
    delete window.donneesImportees;
    console.log('‚úÖ Donn√©es globales nettoy√©es');
    
    console.log('‚úÖ SUCC√àS - √âtats r√©initialis√©s compl√®tement');
}

/**
 * D√©finir l'√©tat d'un indicateur LED (sans ic√¥nes)
 * @param {string} indicatorId - ID de l'indicateur
 * @param {string} state - √âtat: 'inactive', 'active', 'completed', 'error'
 */
function definirEtatIndicateur(indicatorId, state) {
    const indicator = document.getElementById(indicatorId);
    if (!indicator) return;
    
    // Supprimer tous les √©tats
    indicator.classList.remove('inactive', 'active', 'completed', 'error');
    
    // Ajouter le nouvel √©tat
    indicator.classList.add(state);
    
    console.log(`üîÑ Indicateur LED ${indicatorId}: ${state}`);
}

/**
 * Afficher la zone de progression
 */
function afficherProgression() {
    const progressInfo = document.getElementById('progress-info');
    if (progressInfo) {
        progressInfo.style.display = 'block';
    }
}

/**
 * Masquer la zone de progression
 */
function masquerProgression() {
    const progressInfo = document.getElementById('progress-info');
    if (progressInfo) {
        progressInfo.style.display = 'none';
    }
}

/**
 * Mettre √† jour la barre de progression
 * @param {number} pourcentage - Pourcentage de progression (0-100)
 * @param {string} titre - Titre de l'√©tape
 * @param {string} description - Description de l'√©tape
 */
function mettreAJourProgression(pourcentage, titre, description) {
    const progressFill = document.getElementById('progress-fill');
    const progressTitle = document.getElementById('progress-title');
    const progressDescription = document.getElementById('progress-description');
    
    if (progressFill) {
        progressFill.style.width = `${pourcentage}%`;
    }
    
    if (progressTitle) {
        progressTitle.textContent = titre;
    }
    
    if (progressDescription) {
        progressDescription.textContent = description;
    }
    
    console.log(`üìä Progression: ${pourcentage}% - ${titre}`);
}

/**
 * Gestion de la section Dump
 */

// Variables globales pour la pagination
window.dumpData = {
    donnees: [],
    headers: [],
    pageActuelle: 1,
    lignesParPage: 10,
    totalPages: 1,
    estOuverte: false
};

/**
 * Basculer l'affichage de la section Dump
 */
function toggleOverviewSection() {
    const content = document.getElementById('overview-content');
    const led = document.getElementById('overview-led');
    const arrow = document.getElementById('overview-arrow');
    
    if (!content) return;
    
    window.dumpData.estOuverte = !window.dumpData.estOuverte;
    
    if (window.dumpData.estOuverte) {
        content.classList.add('expanded');
        if (led) led.classList.add('active');
        if (arrow) arrow.classList.add('rotated');
    } else {
        content.classList.remove('expanded');
        if (led) led.classList.remove('active');
        if (arrow) arrow.classList.remove('rotated');
    }
    
    console.log(`üìã Section Overview: ${window.dumpData.estOuverte ? 'ouverte' : 'ferm√©e'}`);
}

// Fonction de compatibilit√© pour l'ancienne section Dump
function toggleDumpSection() {
    toggleOverviewSection();
}

/**
 * Basculer l'affichage de la section Chargement
 */
function toggleChargementSection() {
    const content = document.getElementById('chargement-content');
    const led = document.getElementById('chargement-led');
    const arrow = document.getElementById('chargement-arrow');
    
    if (!content) return;
    
    const isExpanded = content.classList.contains('expanded');
    
    if (isExpanded) {
        content.classList.remove('expanded');
        if (led) led.classList.remove('active');
        if (arrow) arrow.classList.remove('rotated');
    } else {
        content.classList.add('expanded');
        if (led) led.classList.add('active');
        if (arrow) arrow.classList.add('rotated');
    }
    
    console.log(`üìÅ Section Chargement: ${isExpanded ? 'ferm√©e' : 'ouverte'}`);
}

/**
 * Basculer l'affichage de la section Dump d'insertion
 */
function toggleInsertionDumpSection() {
    const content = document.getElementById('insertion-dump-content');
    const led = document.getElementById('insertion-dump-led');
    const arrow = document.getElementById('insertion-dump-arrow');
    
    if (!content) return;
    
    const isOpen = content.style.display !== 'none';
    
    if (!isOpen) {
        content.style.display = 'block';
        if (led) led.classList.add('active');
        if (arrow) arrow.classList.add('rotated');
        console.log('üìã Section Dump d\'insertion: ouverte');
    } else {
        content.style.display = 'none';
        if (led) led.classList.remove('active');
        if (arrow) arrow.classList.remove('rotated');
        console.log('üìã Section Dump d\'insertion: ferm√©e');
    }
}

/**
 * Ajouter une requ√™te d'insertion au dump
 */
function ajouterAuDumpInsertion(requeteSQL, donnees, identifiant) {
    console.log('üìã Ajout au dump d\'insertion:', identifiant);
    console.log('üìã Requ√™te SQL compl√®te:', requeteSQL);
    
    // Initialiser le stockage des insertions si n√©cessaire
    if (!window.insertionDump) {
        window.insertionDump = [];
    }
    
    // Cr√©er l'entr√©e d'insertion
    const insertion = {
        id: Date.now(),
        timestamp: new Date().toLocaleString(),
        requete: requeteSQL, // Requ√™te d√©j√† compl√®te avec les vraies valeurs
        donnees: donnees,
        identifiant: identifiant
    };
    
    // Ajouter au d√©but de la liste (plus r√©cent en premier)
    window.insertionDump.unshift(insertion);
    
    // Limiter √† 50 insertions maximum
    if (window.insertionDump.length > 50) {
        window.insertionDump = window.insertionDump.slice(0, 50);
    }
    
    // Mettre √† jour l'affichage
    mettreAJourDumpInsertion();
    
    // Afficher automatiquement la section si c'est la premi√®re insertion
    if (window.insertionDump.length === 1) {
        const section = document.getElementById('insertion-dump-section');
        if (section) {
            section.style.display = 'block';
        }
    }
}

/**
 * Mettre √† jour l'affichage du dump d'insertion
 */
function mettreAJourDumpInsertion() {
    const countElement = document.getElementById('insertion-count');
    const listElement = document.getElementById('insertion-dump-list');
    const emptyElement = document.getElementById('insertion-dump-empty');
    
    if (!window.insertionDump) {
        window.insertionDump = [];
    }
    
    // Mettre √† jour le compteur
    if (countElement) {
        countElement.textContent = window.insertionDump.length;
    }
    
    // Mettre √† jour la liste
    if (listElement) {
        if (window.insertionDump.length === 0) {
            // Afficher l'√©tat vide
            if (emptyElement) {
                emptyElement.style.display = 'block';
            }
            listElement.innerHTML = '<div class="dump-empty" id="insertion-dump-empty"><p>Aucune requ√™te d\'insertion</p><p class="dump-empty-hint">Les requ√™tes d\'insertion appara√Ætront ici</p></div>';
        } else {
            // Masquer l'√©tat vide et afficher les insertions
            if (emptyElement) {
                emptyElement.style.display = 'none';
            }
            
            const html = window.insertionDump.map(insertion => `
                <div class="insertion-item">
                    <div class="insertion-header">
                        <span>Insertion #${insertion.identifiant}</span>
                        <span class="insertion-timestamp">${insertion.timestamp}</span>
                    </div>
                    <div class="insertion-query">${insertion.requete}</div>
                    <div class="insertion-data">${JSON.stringify(insertion.donnees, null, 2)}</div>
                </div>
            `).join('');
            
            listElement.innerHTML = html;
        }
    }
}

/**
 * Effacer le dump d'insertion
 */
function effacerDumpInsertion() {
    if (confirm('√ätes-vous s√ªr de vouloir effacer toutes les requ√™tes d\'insertion ?')) {
        console.log('üóëÔ∏è Effacement du dump d\'insertion');
        window.insertionDump = [];
        mettreAJourDumpInsertion();
        YesDataUtils.showNotification('Dump d\'insertion effac√©', 'success');
    }
}

/**
 * Basculer l'affichage de la section Dump d'import/validation
 */
function toggleImportDumpSection() {
    const content = document.getElementById('import-dump-content');
    const led = document.getElementById('import-dump-led');
    const arrow = document.getElementById('import-dump-arrow');
    
    if (!content) return;
    
    const isOpen = content.style.display !== 'none';
    
    if (!isOpen) {
        content.style.display = 'block';
        if (led) led.classList.add('active');
        if (arrow) arrow.classList.add('rotated');
        console.log('üìã Section Dump d\'import/validation: ouverte');
    } else {
        content.style.display = 'none';
        if (led) led.classList.remove('active');
        if (arrow) arrow.classList.remove('rotated');
        console.log('üìã Section Dump d\'import/validation: ferm√©e');
    }
}

/**
 * Formater une valeur pour l'affichage SQL
 */
function formaterValeurSQL(valeur) {
    if (valeur === null || valeur === undefined) {
        return 'NULL';
    }
    if (typeof valeur === 'string') {
        // Utiliser RegexPatterns pour √©chapper les guillemets
        return `'${RegexPatterns.escapeSQLQuotes(valeur)}'`;
    }
    if (typeof valeur === 'number') {
        return valeur.toString();
    }
    if (typeof valeur === 'boolean') {
        return valeur ? 'TRUE' : 'FALSE';
    }
    if (typeof valeur === 'object') {
        // Pour les objets/arrays, les convertir en JSON et √©chapper
        return `'${RegexPatterns.escapeSQLQuotes(JSON.stringify(valeur))}'`;
    }
    return `'${RegexPatterns.escapeSQLQuotes(String(valeur))}'`;
}

/**
 * Construire une requ√™te SQL compl√®te avec les vraies valeurs
 */
function construireRequeteSQL(template, valeurs) {
    // Utiliser RegexPatterns pour remplacer les placeholders
    let index = 0;
    return template.replace(RegexPatterns.SQL_PLACEHOLDER, () => {
        if (index < valeurs.length) {
            return formaterValeurSQL(valeurs[index++]);
        }
        return '?';
    });
}

/**
 * Ajouter une requ√™te d'import/validation au dump
 */
function ajouterAuImportDump(requeteSQL, donnees, etape, details = {}) {
    console.log('üìã Ajout au dump d\'import/validation:', etape);
    console.log('üìã Requ√™te SQL compl√®te:', requeteSQL);
    
    // Initialiser le stockage des requ√™tes d'import si n√©cessaire
    if (!window.importDump) {
        window.importDump = [];
    }
    
    // Cr√©er l'entr√©e d'import
    const importEntry = {
        id: Date.now(),
        timestamp: new Date().toLocaleString(),
        etape: etape,
        requete: requeteSQL, // Requ√™te d√©j√† compl√®te avec les vraies valeurs
        donnees: donnees,
        details: details
    };
    
    // Ajouter au d√©but de la liste (plus r√©cent en premier)
    window.importDump.unshift(importEntry);
    
    // Limiter √† 100 requ√™tes maximum
    if (window.importDump.length > 100) {
        window.importDump = window.importDump.slice(0, 100);
    }
    
    // Mettre √† jour l'affichage
    mettreAJourImportDump();
    
    // Afficher automatiquement la section si c'est la premi√®re requ√™te
    if (window.importDump.length === 1) {
        const section = document.getElementById('import-dump-section');
        if (section) {
            section.style.display = 'block';
        }
    }
}

/**
 * Mettre √† jour l'affichage du dump d'import/validation
 */
function mettreAJourImportDump() {
    const countElement = document.getElementById('import-dump-count');
    const listElement = document.getElementById('import-dump-list');
    const emptyElement = document.getElementById('import-dump-empty');
    
    if (!window.importDump) {
        window.importDump = [];
    }
    
    // Mettre √† jour le compteur
    if (countElement) {
        countElement.textContent = window.importDump.length;
    }
    
    // Mettre √† jour la liste
    if (listElement) {
        if (window.importDump.length === 0) {
            // Afficher l'√©tat vide
            if (emptyElement) {
                emptyElement.style.display = 'block';
            }
            listElement.innerHTML = '<div class="dump-empty" id="import-dump-empty"><p>Aucune erreur d√©tect√©e</p><p class="dump-empty-hint">Toutes les erreurs d\'import, validation et insertion DB appara√Ætront ici avec d√©tails techniques</p></div>';
        } else {
            // Masquer l'√©tat vide et afficher les requ√™tes
            if (emptyElement) {
                emptyElement.style.display = 'none';
            }
            
            const html = window.importDump.map(entry => {
                const etapeColor = entry.etape === 'Import' ? '#4ecdc4' : '#ffa726';
                const donneesStr = Array.isArray(entry.donnees) ? 
                    `${entry.donnees.length} lignes` : 
                    JSON.stringify(entry.donnees, null, 2);
                
                return `
                    <div class="insertion-item">
                        <div class="insertion-header">
                            <span style="color: ${etapeColor};">${entry.etape}</span>
                            <span class="insertion-timestamp">${entry.timestamp}</span>
                        </div>
                        <div class="insertion-query">${entry.requete}</div>
                        <div class="insertion-data">
                            <strong>Donn√©es:</strong> ${donneesStr}
                            ${entry.details && Object.keys(entry.details).length > 0 ? 
                                `<br><strong>D√©tails:</strong> ${JSON.stringify(entry.details, null, 2)}` : 
                                ''}
                        </div>
                    </div>
                `;
            }).join('');
            
            listElement.innerHTML = html;
        }
    }
}

/**
 * Effacer le dump d'import/validation
 */
function effacerImportDump() {
    if (confirm('√ätes-vous s√ªr de vouloir effacer toutes les erreurs ?')) {
        console.log('üóëÔ∏è Effacement du dump d\'erreurs');
        
        // Effacer la liste des erreurs
        const liste = document.getElementById('import-dump-list');
        if (liste) {
            liste.innerHTML = '<div class="dump-empty" id="import-dump-empty"><p>Aucune erreur d√©tect√©e</p><p class="dump-empty-hint">Toutes les erreurs d\'import, validation et insertion DB appara√Ætront ici avec d√©tails techniques</p></div>';
        }
        
        // R√©initialiser le compteur
        const countElement = document.getElementById('import-dump-count');
        if (countElement) {
            countElement.textContent = '0';
        }
        
        YesDataUtils.showNotification('Dump d\'erreurs effac√©', 'success');
    }
}

/**
 * Initialiser la section Dump avec les donn√©es
 * @param {Object} donnees - Donn√©es import√©es
 */
function initialiserDump(donnees) {
    console.log('üö® CHARGEMENT - D√©but initialiserDump');
    console.log('üö® CHARGEMENT - Donn√©es re√ßues:', donnees);
    console.log('üö® CHARGEMENT - Type des donn√©es:', typeof donnees);
    console.log('üö® CHARGEMENT - Structure:', {
        hasDonnees: !!donnees?.donnees,
        isArray: Array.isArray(donnees?.donnees),
        length: donnees?.donnees?.length || 0,
        hasHeaders: !!donnees?.headers
    });
    
    if (!donnees || !donnees.donnees || !Array.isArray(donnees.donnees)) {
        console.error('‚ùå CHARGEMENT - Aucune donn√©e valide pour le dump');
        console.error('‚ùå CHARGEMENT - Donn√©es re√ßues:', donnees);
        return;
    }
    
    // Stocker les donn√©es
    window.dumpData.donnees = donnees.donnees;
    window.dumpData.headers = donnees.headers || [];
    window.dumpData.pageActuelle = 1;
    window.dumpData.totalPages = Math.ceil(donnees.donnees.length / window.dumpData.lignesParPage);
    
    // Afficher la section
    const overviewSection = document.getElementById('overview-section');
    if (overviewSection) {
        overviewSection.style.display = 'block';
    }
    
    // G√©n√©rer le tableau
    genererTableauDump();
    
    // Mettre √† jour les contr√¥les
    mettreAJourControlesNavigation();
    
    console.log(`üìä Dump initialis√©: ${donnees.donnees.length} lignes, ${window.dumpData.totalPages} pages`);
}

/**
 * G√©n√©rer le tableau HTML avec les donn√©es de la page actuelle
 */
function genererTableauDump() {
    console.log('üö® CHARGEMENT - D√©but genererTableauDump');
    console.log('üö® CHARGEMENT - window.dumpData:', window.dumpData);
    console.log('üö® CHARGEMENT - Nombre de donn√©es:', window.dumpData?.donnees?.length || 0);
    console.log('üö® CHARGEMENT - Headers:', window.dumpData?.headers || []);
    
    const thead = document.getElementById('dump-thead');
    const tbody = document.getElementById('dump-tbody');
    const tableContainer = document.querySelector('.dump-table-container');
    const emptyState = document.getElementById('dump-empty');
    
    console.log('üö® CHARGEMENT - √âl√©ments DOM:', {
        thead: !!thead,
        tbody: !!tbody,
        tableContainer: !!tableContainer,
        emptyState: !!emptyState
    });
    
    if (!thead || !tbody) {
        console.error('‚ùå CHARGEMENT - √âl√©ments DOM manquants');
        return;
    }
    
    // V√©rifier s'il y a des donn√©es
    if (window.dumpData.donnees.length === 0) {
        if (tableContainer) tableContainer.style.display = 'none';
        if (emptyState) emptyState.style.display = 'block';
        return;
    }
    
    if (tableContainer) tableContainer.style.display = 'block';
    if (emptyState) emptyState.style.display = 'none';
    
    // G√©n√©rer les en-t√™tes
    thead.innerHTML = '';
    const headerRow = document.createElement('tr');
    
    if (window.dumpData.headers.length > 0) {
        window.dumpData.headers.forEach(header => {
            const th = document.createElement('th');
            th.textContent = header || 'Colonne';
            th.title = header;
            headerRow.appendChild(th);
        });
    } else {
        // G√©n√©rer des en-t√™tes par d√©faut si pas d'headers
        const premiereLigne = window.dumpData.donnees[0];
        if (premiereLigne && typeof premiereLigne === 'object') {
            Object.keys(premiereLigne).forEach(key => {
                const th = document.createElement('th');
                th.textContent = key;
                th.title = key;
                headerRow.appendChild(th);
            });
        }
    }
    
    thead.appendChild(headerRow);
    
    // G√©n√©rer les lignes de donn√©es pour la page actuelle
    tbody.innerHTML = '';
    const debut = (window.dumpData.pageActuelle - 1) * window.dumpData.lignesParPage;
    const fin = Math.min(debut + window.dumpData.lignesParPage, window.dumpData.donnees.length);
    
    for (let i = debut; i < fin; i++) {
        const donnee = window.dumpData.donnees[i];
        const row = document.createElement('tr');
        
        if (typeof donnee === 'object' && donnee !== null) {
            // Utiliser les headers ou les cl√©s de l'objet
            const cles = window.dumpData.headers.length > 0 ? window.dumpData.headers : Object.keys(donnee);
            
            cles.forEach(cle => {
                const td = document.createElement('td');
                const valeur = donnee[cle];
                td.textContent = valeur !== null && valeur !== undefined ? String(valeur) : '';
                td.title = td.textContent;
                row.appendChild(td);
            });
        } else {
            // Donn√©e simple
            const td = document.createElement('td');
            td.textContent = String(donnee);
            td.title = td.textContent;
            row.appendChild(td);
        }
        
        tbody.appendChild(row);
    }
    
    // Mettre √† jour les informations
    const lignesAffichees = document.getElementById('lignes-affichees');
    const totalLignes = document.getElementById('total-lignes');
    
    if (lignesAffichees) {
        lignesAffichees.textContent = fin - debut;
    }
    if (totalLignes) {
        totalLignes.textContent = window.dumpData.donnees.length;
    }
}

/**
 * Mettre √† jour les contr√¥les de navigation
 */
function mettreAJourControlesNavigation() {
    const currentPageInput = document.getElementById('current-page');
    const totalPagesSpan = document.getElementById('total-pages');
    const firstBtn = document.getElementById('first-page');
    const prevBtn = document.getElementById('prev-page');
    const nextBtn = document.getElementById('next-page');
    const lastBtn = document.getElementById('last-page');
    
    if (currentPageInput) {
        currentPageInput.value = window.dumpData.pageActuelle;
        currentPageInput.max = window.dumpData.totalPages;
    }
    
    if (totalPagesSpan) {
        totalPagesSpan.textContent = window.dumpData.totalPages;
    }
    
    // √âtat des boutons
    const estPremierePage = window.dumpData.pageActuelle === 1;
    const estDernierePage = window.dumpData.pageActuelle === window.dumpData.totalPages;
    
    if (firstBtn) firstBtn.disabled = estPremierePage;
    if (prevBtn) prevBtn.disabled = estPremierePage;
    if (nextBtn) nextBtn.disabled = estDernierePage;
    if (lastBtn) lastBtn.disabled = estDernierePage;
}

/**
 * Navigation - Aller √† la premi√®re page
 */
function allerPremierePage() {
    if (window.dumpData.pageActuelle > 1) {
        window.dumpData.pageActuelle = 1;
        genererTableauDump();
        mettreAJourControlesNavigation();
    }
}

/**
 * Navigation - Page pr√©c√©dente
 */
function pagePrecedente() {
    if (window.dumpData.pageActuelle > 1) {
        window.dumpData.pageActuelle--;
        genererTableauDump();
        mettreAJourControlesNavigation();
    }
}

/**
 * Navigation - Page suivante
 */
function pageSuivante() {
    if (window.dumpData.pageActuelle < window.dumpData.totalPages) {
        window.dumpData.pageActuelle++;
        genererTableauDump();
        mettreAJourControlesNavigation();
    }
}

/**
 * Navigation - Aller √† la derni√®re page
 */
function allerDernierePage() {
    if (window.dumpData.pageActuelle < window.dumpData.totalPages) {
        window.dumpData.pageActuelle = window.dumpData.totalPages;
        genererTableauDump();
        mettreAJourControlesNavigation();
    }
}

/**
 * Navigation - Aller √† une page sp√©cifique
 * @param {number} page - Num√©ro de page
 */
function allerALaPage(page) {
    const pageNum = parseInt(page);
    if (pageNum >= 1 && pageNum <= window.dumpData.totalPages) {
        window.dumpData.pageActuelle = pageNum;
        genererTableauDump();
        mettreAJourControlesNavigation();
    } else {
        // Remettre la valeur correcte si invalide
        const currentPageInput = document.getElementById('current-page');
        if (currentPageInput) {
            currentPageInput.value = window.dumpData.pageActuelle;
        }
    }
}

/*===============================================
  FONCTIONS MONITORING
===============================================*/

/**
 * Wrapper synchrone pour calculerConsolidation (appel√© depuis HTML)
 */
function calculerConsolidation() {
    calculerConsolidationAsync().catch(error => {
        console.error('‚ùå Erreur calculerConsolidation:', error);
        YesDataUtils.showNotification(`Erreur: ${error.message}`, 'error');
    });
}

/**
 * Calculer la consolidation des donn√©es (version async)
 */
async function calculerConsolidationAsync() {
    console.log('üßÆ D√©but du calcul de consolidation [SQL.js NATIF]');
    
    // V√©rifier que DatabaseManager est pr√™t
    if (!window.DatabaseManager.isInitialized()) {
        console.error('‚ùå DatabaseManager non initialis√©');
        YesDataUtils.showNotification('Base de donn√©es non initialis√©e. Veuillez recharger la page.', 'error');
        return;
    }
    
    try {
        // Marquer le d√©but du calcul
        definirEtatIndicateur('calcul-status', 'active');
        
        console.log('üöÄ Calculs de consolidation avec SQL.js natif');
        
        // üéØ R√âVOLUTION: Calculs directs avec SQL natif !
        // Afficher la section des requ√™tes SQL
        afficherSectionRequetesSQL();
        
        // Effectuer les calculs avec des vraies requ√™tes SQL
        const resultats = await effectuerCalculsConsolidationSQL();
        
        // Sauvegarder dans YesData_Summary
        sauvegarderDansHistorique(resultats);
        
        // Afficher les r√©sultats
        afficherResultatsConsolidation(resultats);
        
        // Marquer comme termin√©
        definirEtatIndicateur('calcul-status', 'completed');
        
        YesDataUtils.showNotification('Calculs de consolidation termin√©s avec succ√®s', 'success');
        
    } catch (error) {
        console.error('‚ùå Erreur dans le calcul de consolidation:', error);
        YesDataUtils.showNotification(`Erreur: ${error.message}`, 'error');
        definirEtatIndicateur('calcul-status', 'inactive');
    }
}

/**
 * Effectuer les calculs de consolidation selon les crit√®res
 */
function effectuerCalculsConsolidation(donnees) {
    // Extraire les donn√©es selon la structure localStorage
    let lignes, headers, dateExtrait;
    
    if (donnees.donnees && donnees.donnees.donnees) {
        // Structure localStorage: { donnees: { donnees: [...], headers: [...] } }
        lignes = donnees.donnees.donnees;
        headers = donnees.donnees.headers || [];
        dateExtrait = donnees.donnees.dateExtrait || new Date().toISOString().split('T')[0];
    } else if (Array.isArray(donnees.donnees)) {
        // Structure directe: { donnees: [...], headers: [...] }
        lignes = donnees.donnees;
        headers = donnees.headers || [];
        dateExtrait = donnees.dateExtrait || new Date().toISOString().split('T')[0];
    } else {
        throw new Error('Structure de donn√©es non reconnue');
    }
    
    console.log(`üìä Analyse de ${lignes.length} lignes avec headers:`, headers);
    
    // Trouver les indices des colonnes n√©cessaires
    const indices = trouverIndicesColonnes(headers);
    console.log('üîç Indices des colonnes:', indices);
    
            // Filtrer les lignes critiques avec Dx √©gal √† 'DP' exactement
    const lignesCritiques = lignes.filter(ligne => {
        const dValue = ligne[indices.d] || '';
        const businessCriticality = ligne[indices.businessCriticality] || '';
        
        return dValue.toString().toUpperCase() === 'DP' && 
               businessCriticality.toString().toUpperCase() === 'CRITICAL';
    });
    
            console.log(`‚úÖ ${lignesCritiques.length} applications critiques trouv√©es (Dx = DP exactement et Business criticality = Critical)`);
    
    // Effectuer les calculs
    const totalCritiques = lignesCritiques.length;
    
    // BSM - Monitored in BSM
    const monitoredBSM = lignesCritiques.filter(ligne => {
        const functionalMonitoring = ligne[indices.functionalMonitoring] || '';
        return functionalMonitoring.toString().toUpperCase() === 'YES';
    }).length;
    
    // BSM - Still To Be Monitored
    const stillToMonitor = lignesCritiques.filter(ligne => {
        const inHCC = ligne[indices.inHCC] || '';
        return inHCC.toString().toUpperCase() === 'NO';
    }).length;
    
    // HCC - Confirmed Not Required in BSM
    const notRequiredBSM = lignesCritiques.filter(ligne => {
        const functionalMonitoring = ligne[indices.functionalMonitoring] || '';
        const hccEligibility = ligne[indices.hccEligibility] || '';
        return functionalMonitoring.toString().toUpperCase() === 'NO' && 
               hccEligibility.toString().toUpperCase() === 'NO';
    }).length;
    
    // HCC - Monitored in HCC
    const monitoredHCC = lignesCritiques.filter(ligne => {
        const inHCC = ligne[indices.inHCC] || '';
        return inHCC.toString().toUpperCase() === 'YES';
    }).length;
    
    // HCC - Confirmed not required in HCC
    const notRequiredHCC = lignesCritiques.filter(ligne => {
        const inHCC = ligne[indices.inHCC] || '';
        const hccEligibility = ligne[indices.hccEligibility] || '';
        return inHCC.toString().toUpperCase() === 'NO' && 
               hccEligibility.toString().toUpperCase() === 'NO';
    }).length;
    
    // Calculer les pourcentages
    const pctNotRequiredBSM = totalCritiques > 0 ? Math.round((notRequiredBSM / totalCritiques) * 100) : 0;
    const pctMonitoredHCC = totalCritiques > 0 ? Math.round((monitoredHCC / totalCritiques) * 100) : 0;
    const pctNotRequiredHCC = totalCritiques > 0 ? Math.round((notRequiredHCC / totalCritiques) * 100) : 0;
    
    // Calculer les donn√©es par section DP*
    const sectionsDP = calculerSectionsDP(lignesCritiques, indices, lignes);
    
    const resultats = {
        date: dateExtrait,
        totalCritiques,
        monitoredBSM,
        stillToMonitor,
        notRequiredBSM,
        pctNotRequiredBSM,
        monitoredHCC,
        pctMonitoredHCC,
        notRequiredHCC,
        pctNotRequiredHCC,
        sectionsDP,
        timestamp: new Date().toISOString()
    };
    
    console.log('üìà R√©sultats des calculs:', resultats);
    return resultats;
}

/**
 * Calculer les donn√©es par section DP*
 */
function calculerSectionsDP(lignesCritiques, indices, toutesLesLignes) {
    const sections = ['DPA', 'DPB', 'DPC', 'DPP', 'DPS'];
    const resultats = {};
    
    // Critical Business Services = nombre total de lignes dans la table
    const criticalBusinessServices = toutesLesLignes.length;
    
                    // Still to be onboarded = lignes DP* + Critical + Functional monitoring (BSM) = YES
    // (utilise LIKE 'DP%' selon le fichier SQL)
    const stillToOnboard = toutesLesLignes.filter(ligne => {
        const dValue = ligne[indices.d] || '';
        const businessCriticality = ligne[indices.businessCriticality] || '';
        const functionalMonitoring = ligne[indices.functionalMonitoring] || '';
        
        return dValue.toString().toUpperCase().startsWith('DP') && 
               businessCriticality.toString().toUpperCase() === 'CRITICAL' &&
               functionalMonitoring.toString().toUpperCase() === 'YES';
    }).length;
    
    resultats['dp'] = {
        criticalBusinessServices: criticalBusinessServices,
        stillToOnboard: stillToOnboard,
        percentage: criticalBusinessServices > 0 ? Math.round((stillToOnboard / criticalBusinessServices) * 100) : 0
    };
    
    console.log(`üìä DP: ${criticalBusinessServices} lignes totales (Critical Business Services), ${stillToOnboard} Still to onboard DP* (${resultats['dp'].percentage}%)`);
    
    // Calcul pour les autres sections DPx
    sections.forEach(prefixe => {
        // Filtrer les lignes qui commencent par ce pr√©fixe ET sont critiques
        const lignesSection = toutesLesLignes.filter(ligne => {
            const dValue = ligne[indices.d] || '';
            const businessCriticality = ligne[indices.businessCriticality] || '';
            return dValue.toString().toUpperCase().startsWith(prefixe) &&
                   businessCriticality.toString().toUpperCase() === 'CRITICAL';
        });
        
        // Calculer les monitored pour cette section
        const monitored = lignesSection.filter(ligne => {
            const functionalMonitoring = ligne[indices.functionalMonitoring] || '';
            return functionalMonitoring.toString().toUpperCase() === 'YES';
        }).length;
        
        resultats[prefixe.toLowerCase()] = {
            total: lignesSection.length,
            monitored: monitored
        };
        
        console.log(`üìä ${prefixe}: ${lignesSection.length} total, ${monitored} monitored`);
    });
    
    return resultats;
}

/**
 * Trouver les indices des colonnes dans les headers
 */
function trouverIndicesColonnes(headers) {
    const mappings = {
        'd': ['Dx', 'D*', 'D', 'Application ID'],
        'appAppli': ['App Appli', 'App. Name', 'App Name', 'Application Name'],
        'appCode': ['App Code', 'App. Code', 'App Code', 'Application Code'],
        'businessCriticality': ['Business criticality', 'Business Criticality', 'Criticality'],
        'functionalMonitoring': ['Functional monitoring (BSM)', 'Functional monitoring', 'Functional Monitoring'],
        'inHCC': ['In HCC', 'HCC'],
        'hccEligibility': ['HCC eligibility', 'HCC Eligibility', 'HCC eligibility AV (Added Value)', 'HCC eligibility AV']
    };
    
    const indices = {};
    
    Object.keys(mappings).forEach(key => {
        const possibleNames = mappings[key];
        let index = -1;
        
        for (const name of possibleNames) {
            index = headers.findIndex(header => 
                header && header.toString().trim().toLowerCase() === name.toLowerCase()
            );
            if (index !== -1) break;
        }
        
        indices[key] = index;
        if (index === -1) {
            console.warn(`‚ö†Ô∏è Colonne "${key}" non trouv√©e. Noms recherch√©s:`, possibleNames);
        }
    });
    
    return indices;
}

/**
 * Sauvegarder les r√©sultats dans l'historique
 */
function sauvegarderDansHistorique(resultats) {
    try {
        const historique = JSON.parse(localStorage.getItem('dioo_summary') || '[]');
        
        // V√©rifier si une entr√©e existe d√©j√† pour cette date
        const indexExistant = historique.findIndex(entry => entry.date === resultats.date);
        
        if (indexExistant !== -1) {
            // Mettre √† jour l'entr√©e existante
            historique[indexExistant] = resultats;
            console.log('üìù Mise √† jour de l\'entr√©e existante pour la date:', resultats.date);
        } else {
            // Ajouter une nouvelle entr√©e
            historique.push(resultats);
            console.log('üìù Nouvelle entr√©e ajout√©e √† l\'historique pour la date:', resultats.date);
        }
        
        // Garder seulement les 10 derni√®res entr√©es
        const historiqueLimit = historique.slice(-10);
        
        localStorage.setItem('dioo_summary', JSON.stringify(historiqueLimit));
        console.log('üíæ Historique sauvegard√© dans localStorage');
        
    } catch (error) {
        console.error('‚ùå Erreur lors de la sauvegarde dans l\'historique:', error);
    }
}

/**
 * Afficher les r√©sultats de consolidation
 */
function afficherResultatsConsolidation(resultats) {
    // Afficher les sections DP*
    const sections = ['dp', 'dpa', 'dpb', 'dpc', 'dpp', 'dps'];
    
    sections.forEach(section => {
        const sectionElement = document.getElementById(`${section}-section`);
        if (sectionElement) {
            sectionElement.style.display = 'block';
        }
    });
    
    // Mettre √† jour les valeurs pour chaque section DP*
    mettreAJourSectionDP(resultats);
    
    // Cr√©er les graphiques pour chaque section
    creerGraphiquesDP(resultats);
    
    console.log('‚ú® R√©sultats affich√©s avec succ√®s');
}

/**
 * Mettre √† jour les sections DP* avec les donn√©es
 */
function mettreAJourSectionDP(resultats) {
    // Mise √† jour sp√©ciale pour la section DP
    const dpData = resultats.sectionsDP?.dp;
    if (dpData) {
        const criticalElement = document.getElementById('critical-business-services');
        const onboardElement = document.getElementById('still-to-onboard');
        
        if (criticalElement) criticalElement.textContent = dpData.criticalBusinessServices;
        if (onboardElement) onboardElement.textContent = dpData.stillToOnboard;
    }
    
    // Mise √† jour pour les autres sections DPx
    const sections = ['dpa', 'dpb', 'dpc', 'dpp', 'dps'];
    
    sections.forEach(section => {
        const sectionData = resultats.sectionsDP?.[section] || { total: 0, monitored: 0 };
        
        // Mettre √† jour les valeurs
        const totalElement = document.getElementById(`${section}-total`);
        const monitoredElement = document.getElementById(`${section}-monitored`);
        
        if (totalElement) totalElement.textContent = sectionData.total;
        if (monitoredElement) monitoredElement.textContent = sectionData.monitored;
    });
}

/**
 * Cr√©er les graphiques pour les sections DP*
 */
function creerGraphiquesDP(resultats) {
    // Cr√©er le graphique sp√©cial pour DP
    const dpData = resultats.sectionsDP?.dp;
    if (dpData) {
        creerGraphiqueSection('dp', dpData);
    }
    
    // Cr√©er les graphiques pour les autres sections DPx
    const sections = ['dpa', 'dpb', 'dpc', 'dpp', 'dps'];
    
    sections.forEach(section => {
        const sectionData = resultats.sectionsDP?.[section] || { total: 0, monitored: 0 };
        creerGraphiqueSection(section, sectionData);
    });
    
    // Cr√©er les nouveaux graphiques BSM et HCC
    creerGraphiquesBSMHCC(resultats);
}

/**
 * Cr√©er un graphique pour une section DP*
 */
function creerGraphiqueSection(section, data) {
    const ctx = document.getElementById(`${section}-chart`);
    if (!ctx) return;
    
    const chartCtx = ctx.getContext('2d');
    
    // D√©truire le graphique existant s'il y en a un
    if (window[`${section}Chart`]) {
        window[`${section}Chart`].destroy();
    }
    
    if (section === 'dp') {
        // Graphique sp√©cial pour DP : camembert repr√©sentant les proportions r√©elles
        const totalCritiques = data.criticalBusinessServices;
        const stillToOnboard = data.stillToOnboard;
        
        window[`${section}Chart`] = new Chart(chartCtx, {
            type: 'doughnut',
            data: {
                labels: ['Critical Business Services', 'Still to be onboarded'],
                datasets: [{
                    data: [totalCritiques, stillToOnboard], // Valeurs absolues pour proportions correctes
                    backgroundColor: [
                        'rgba(63, 182, 255, 0.8)',    // Bleu pour Critical Business Services
                        'rgba(255, 193, 7, 0.8)'      // Jaune/Orange pour Still to onboard
                    ],
                    borderColor: [
                        'rgba(63, 182, 255, 1)',
                        'rgba(255, 193, 7, 1)'
                    ],
                    borderWidth: 2
                }]
            },
            options: {
                responsive: true,
                plugins: {
                    legend: {
                        display: true,  // Afficher les l√©gendes
                        position: 'bottom',
                        labels: {
                            // Police de chaque l√©gende de la couleur de son segment
                            generateLabels: function(chart) {
                                const data = chart.data;
                                if (data.labels.length && data.datasets.length) {
                                    return data.labels.map((label, i) => {
                                        const dataset = data.datasets[0];
                                        const backgroundColor = dataset.backgroundColor[i];
                                        const borderColor = dataset.borderColor[i];
                                        
                                        // Logique sp√©ciale pour le camembert DP
                                        let text;
                                        if (i === 0) {
                                            // Critical Business Services : pas de pourcentage
                                            text = `${label}: ${dataset.data[i]}`;
                                        } else {
                                            // Still to be onboarded : pourcentage par rapport √† Critical Business Services
                                            const criticalBusinessServices = dataset.data[0];
                                            const percentage = criticalBusinessServices > 0 ? Math.round((dataset.data[i] / criticalBusinessServices) * 100) : 0;
                                            text = `${label}: ${dataset.data[i]} (${percentage}%)`;
                                        }
                                        
                                        return {
                                            text: text,
                                            fillStyle: backgroundColor,
                                            strokeStyle: borderColor,
                                            lineWidth: 2,
                                            hidden: false,
                                            index: i,
                                            fontColor: borderColor  // Couleur du texte = couleur du segment
                                        };
                                    });
                                }
                                return [];
                            },
                            font: {
                                size: 11
                            },
                            padding: 8
                        }
                    },
                    tooltip: {
                        callbacks: {
                            label: function(context) {
                                if (context.dataIndex === 0) {
                                    // Critical Business Services : pas de pourcentage
                                    return `Critical Business Services: ${totalCritiques}`;
                                } else {
                                    // Still to be onboarded : pourcentage par rapport √† Critical Business Services
                                    const percentage = totalCritiques > 0 ? Math.round((stillToOnboard / totalCritiques) * 100) : 0;
                                    return `Still to onboard: ${stillToOnboard} (${percentage}%)`;
                                }
                            }
                        }
                    }
                }
            }
        });
    } else {
        // Graphique standard pour les autres sections DPx
        window[`${section}Chart`] = new Chart(chartCtx, {
            type: 'doughnut',
            data: {
                labels: ['Monitored', 'Not Monitored'],
                datasets: [{
                    data: [data.monitored, data.total - data.monitored],
                    backgroundColor: [
                        'rgba(63, 182, 255, 0.8)',
                        'rgba(255, 193, 7, 0.8)'
                    ],
                    borderColor: [
                        'rgba(63, 182, 255, 1)',
                        'rgba(255, 193, 7, 1)'
                    ],
                    borderWidth: 2
                }]
            },
            options: {
                responsive: true,
                plugins: {
                    legend: {
                        display: true,
                        position: 'bottom',
                        labels: {
                            // Police de chaque l√©gende de la couleur de son segment
                            generateLabels: function(chart) {
                                const data = chart.data;
                                if (data.labels.length && data.datasets.length) {
                                    return data.labels.map((label, i) => {
                                        const dataset = data.datasets[0];
                                        const backgroundColor = dataset.backgroundColor[i];
                                        const borderColor = dataset.borderColor[i];
                                        
                                        // Calculer le pourcentage
                                        const total = dataset.data.reduce((a, b) => a + b, 0);
                                        const percentage = Math.round((dataset.data[i] / total) * 100);
                                        
                                        return {
                                            text: `${label}: ${dataset.data[i]} (${percentage}%)`,
                                            fillStyle: backgroundColor,
                                            strokeStyle: borderColor,
                                            lineWidth: 2,
                                            hidden: false,
                                            index: i,
                                            fontColor: borderColor  // Couleur du texte = couleur du segment
                                        };
                                    });
                                }
                                return [];
                            },
                            font: {
                                size: 11
                            },
                            padding: 8
                        }
                    }
                }
            }
        });
    }
}

/**
 * Cr√©er les graphiques BSM et HCC
 */
function creerGraphiquesBSMHCC(resultats) {
    const totalCritiques = resultats.totalCritiques || 0;
    const monitoredBSM = resultats.monitoredBSM || 0;
    const notRequiredBSM = resultats.notRequiredBSM || 0;
    const monitoredHCC = resultats.monitoredHCC || 0;
    const notRequiredHCC = resultats.notRequiredHCC || 0;
    
    // Calcul des valeurs pour "Critical eligible onboarded"
    const criticalEligibleBSM = totalCritiques - monitoredBSM - notRequiredBSM;
    const criticalEligibleHCC = totalCritiques - monitoredHCC - notRequiredHCC;
    
    // Ligne 1: BSM
    creerPetitCamembert('monitored-bsm-chart', 
        ['Monitored', 'Not Monitored'], 
        [monitoredBSM, notRequiredBSM],
        ['rgba(63, 182, 255, 0.8)', 'rgba(255, 193, 7, 0.8)']);
    
    creerPetitCamembert('not-required-bsm-chart', 
        ['Not Required', 'Required'], 
        [notRequiredBSM, totalCritiques - notRequiredBSM],
        ['rgba(63, 182, 255, 0.8)', 'rgba(255, 193, 7, 0.8)']);
    
    creerPetitCamembert('critical-eligible-bsm-chart', 
        ['Eligible', 'Others'], 
        [Math.max(0, criticalEligibleBSM), totalCritiques - Math.max(0, criticalEligibleBSM)],
        ['rgba(63, 182, 255, 0.8)', 'rgba(255, 193, 7, 0.8)']);
    
    // Ligne 2: HCC
    creerPetitCamembert('onboarded-hcc-chart', 
        ['Onboarded', 'Not Onboarded'], 
        [monitoredHCC, notRequiredHCC],
        ['rgba(63, 182, 255, 0.8)', 'rgba(255, 193, 7, 0.8)']);
    
    creerPetitCamembert('not-required-hcc-chart', 
        ['Not Required', 'Required'], 
        [notRequiredHCC, totalCritiques - notRequiredHCC],
        ['rgba(63, 182, 255, 0.8)', 'rgba(255, 193, 7, 0.8)']);
    
    creerPetitCamembert('critical-eligible-hcc-chart', 
        ['Eligible', 'Others'], 
        [Math.max(0, criticalEligibleHCC), totalCritiques - Math.max(0, criticalEligibleHCC)],
        ['rgba(63, 182, 255, 0.8)', 'rgba(255, 193, 7, 0.8)']);
}

/**
 * Cr√©er un petit camembert avec style identique au camembert principal
 */
function creerPetitCamembert(canvasId, labels, data, colors) {
    const ctx = document.getElementById(canvasId);
    if (!ctx) return;
    
    const chartCtx = ctx.getContext('2d');
    
    // D√©truire le graphique existant s'il y en a un
    if (window[`${canvasId}Chart`]) {
        window[`${canvasId}Chart`].destroy();
    }
    
    window[`${canvasId}Chart`] = new Chart(chartCtx, {
        type: 'doughnut',
        data: {
            labels: labels,
            datasets: [{
                data: data,
                backgroundColor: colors,
                borderColor: colors.map(color => color.replace('0.8', '1')),
                borderWidth: 2  // M√™me √©paisseur que le camembert principal
            }]
        },
        options: {
            responsive: true,
            maintainAspectRatio: true,
            plugins: {
                legend: {
                    display: true,
                    position: 'bottom',
                    labels: {
                        // Police de chaque l√©gende de la couleur de son segment
                        generateLabels: function(chart) {
                            const data = chart.data;
                            if (data.labels.length && data.datasets.length) {
                                return data.labels.map((label, i) => {
                                    const dataset = data.datasets[0];
                                    const backgroundColor = dataset.backgroundColor[i];
                                    const borderColor = dataset.borderColor[i];
                                    
                                    return {
                                        text: `${label}: ${dataset.data[i]}`,
                                        fillStyle: backgroundColor,
                                        strokeStyle: borderColor,
                                        lineWidth: 2,
                                        hidden: false,
                                        index: i,
                                        fontColor: borderColor  // Couleur du texte = couleur du segment
                                    };
                                });
                            }
                            return [];
                        },
                        font: {
                            size: 9  // Taille r√©duite pour les petits camemberts
                        },
                        padding: 4
                    }
                },
                tooltip: {
                    callbacks: {
                        label: function(context) {
                            const total = data.reduce((a, b) => a + b, 0);
                            const percentage = Math.round((context.parsed / total) * 100);
                            return `${context.label}: ${context.parsed} (${percentage}%)`;
                        }
                    }
                }
            }
        }
    });
}

// Anciennes fonctions BSM/HCC supprim√©es - remplac√©es par les sections DP*

/**
 * Basculer l'affichage d'une section
 */
function toggleSection(contentId) {
    const content = document.getElementById(contentId);
    const ledId = contentId.replace('-content', '-led');
    const arrowId = contentId.replace('-content', '-arrow');
    const led = document.getElementById(ledId);
    const arrow = document.getElementById(arrowId);
    
    if (content && content.classList.contains('expanded')) {
        // Fermer la section
        content.classList.remove('expanded');
        if (led) led.classList.remove('active');
        if (arrow) arrow.classList.remove('rotated');
    } else {
        // Ouvrir la section
        if (content) content.classList.add('expanded');
        if (led) led.classList.add('active');
        if (arrow) arrow.classList.add('rotated');
    }
}

/**
 * Afficher les d√©tails d'une entr√©e d'historique
 */
function afficherDetailEntry(date) {
    try {
        const historique = JSON.parse(localStorage.getItem('dioo_summary') || '[]');
        const entry = historique.find(e => e.date === date);
        
        if (entry) {
            const details = `
Date: ${entry.date}
Total d'applications critiques: ${entry.totalCritiques}
Monitored in BSM: ${entry.monitoredBSM}
Still To Be Monitored: ${entry.stillToMonitor}
Confirmed Not Required in BSM: ${entry.notRequiredBSM} (${entry.pctNotRequiredBSM}%)
Monitored in HCC: ${entry.monitoredHCC} (${entry.pctMonitoredHCC}%)
Confirmed Not Required in HCC: ${entry.notRequiredHCC} (${entry.pctNotRequiredHCC}%)
            `;
            
            YesDataUtils.showNotification(details, 'info');
        }
    } catch (error) {
        console.error('‚ùå Erreur lors de l\'affichage des d√©tails:', error);
        YesDataUtils.showNotification('Erreur lors de l\'affichage des d√©tails', 'error');
    }
}

/**
 * Afficher les 10 premi√®res lignes de la table dans la console
 */
function afficher10PremiersLignes() {
    const donnees = JSON.parse(localStorage.getItem('dioo_donnees') || '{}');
    
    let lignes, headers;
    
    if (donnees.donnees && donnees.donnees.donnees && Array.isArray(donnees.donnees.donnees)) {
        lignes = donnees.donnees.donnees;
        headers = donnees.donnees.headers || [];
    } else if (donnees.donnees && Array.isArray(donnees.donnees)) {
        lignes = donnees.donnees;
        headers = donnees.headers || [];
    } else {
        console.log('‚ùå Aucune donn√©e trouv√©e dans la base');
        return null;
    }
    
    const premiersLignes = lignes.slice(0, 10);
    
    console.log('üìä Headers:', headers);
    console.log('üìã 10 premi√®res lignes:', premiersLignes);
    console.log(`üìà Total: ${lignes.length} lignes dans la base`);
    
    return {
        headers: headers,
        lignes: premiersLignes,
        total: lignes.length
    };
}

/*===============================================
  FONCTIONS DATABASE
===============================================*/

/**
 * Toggle des sections de la page DataBase
 */
function toggleDatabaseSection(contentId) {
    const content = document.getElementById(contentId);
    const sectionId = contentId.replace('-content', '');
    const led = document.getElementById(`${sectionId}-led`);
    const arrow = document.getElementById(`${sectionId}-arrow`);
    
    if (content && led && arrow) {
        const isExpanded = content.style.display === 'block';
        
        if (isExpanded) {
            content.style.display = 'none';
            led.classList.remove('active');
            arrow.textContent = '‚ñº';
        } else {
            content.style.display = 'block';
            led.classList.add('active');
            arrow.textContent = '‚ñ≤';
        }
    }
}

/**
 * Wrapper synchrone pour executeQuery (appel√© depuis HTML)
 */
function executeQuery(queryType) {
    executeQueryAsync(queryType).catch(error => {
        console.error('‚ùå Erreur executeQuery:', error);
        afficherErreur(`Erreur: ${error.message}`);
    });
}

/**
 * Ex√©cuter une requ√™te pr√©d√©finie (version async)
 */
async function executeQueryAsync(queryType) {
    console.log(`üîç DataBase - Ex√©cution de la requ√™te pr√©d√©finie: ${queryType} [SQL.js NATIF]`);
    
    // V√©rifier que DatabaseManager est pr√™t
    if (!window.DatabaseManager.isInitialized()) {
        console.error('‚ùå DataBase - DatabaseManager non initialis√©');
        afficherErreur('Base de donn√©es non initialis√©e. Veuillez recharger la page.');
        return;
    }
    
    // R√©cup√©ration des donn√©es pour compatibilit√© avec certains cas
    let lignes = [], headers = [];
    try {
        const donnees = await window.DatabaseManager.getDonnees();
        const extracted = extractDataStructure(donnees);
        lignes = extracted.lignes;
        headers = extracted.headers;
        console.log(`üìä Donn√©es r√©cup√©r√©es: ${lignes.length} lignes, ${headers.length} colonnes`);
    } catch (error) {
        console.log('‚ö†Ô∏è Pas de donn√©es existantes, cr√©ation structure vide');
        lignes = [];
        headers = ['Dx', 'App Appli', 'App Code', 'Operator/Department', 'Business criticality', 'Functional monitoring (BSM)', 'In HCC', 'HCC eligibility'];
    }
    
    // Gestion sp√©ciale pour l'ajout de ligne al√©atoire sans donn√©es
    if (!lignes || lignes.length === 0) {
        if (queryType === 'ajouter_ligne_aleatoire') {
            console.log('üé≤ Cr√©ation structure de base pour ajout ligne al√©atoire');
            headers = ['Dx', 'App Appli', 'App Code', 'Operator/Department', 'Business criticality', 'Functional monitoring (BSM)', 'In HCC', 'HCC eligibility'];
            lignes = [];
        } else {
            console.error('‚ùå DataBase - Aucune donn√©e disponible');
            afficherErreur('Aucune donn√©e disponible. Veuillez d\'abord charger un fichier.');
            return;
        }
    }
    
    console.log(`‚úÖ DataBase - Donn√©es pr√™tes: ${lignes.length} lignes, ${headers.length} colonnes`);
    
    let resultats = [];
    let titre = '';
    
    try {
        console.log(`üîÑ DataBase - Traitement de la requ√™te: ${queryType}`);
        
        switch (queryType) {
            case 'info_tables':
                console.log('üìä DataBase - Informations sur les tables [SQL.js NATIF]');
                titre = 'Informations sur les tables de la base';
                
                try {
                    // üöÄ Vraie requ√™te SQLite pour lister les tables
                    const sqlInfoTables = "SELECT name FROM sqlite_master WHERE type='table'";
                    const tables = await window.DatabaseManager.executeQuery(sqlInfoTables);
                    
                    // Obtenir les statistiques de chaque table
                    resultats = [];
                    for (const table of tables) {
                        const tableName = table.name;
                        const countResult = await window.DatabaseManager.executeQuery(`SELECT COUNT(*) as count FROM ${tableName}`);
                        const count = countResult[0].count;
                        
                        // Obtenir les colonnes
                        const columnsResult = await window.DatabaseManager.executeQuery(`PRAGMA table_info(${tableName})`);
                        const columnCount = columnsResult.length;
                        
                        resultats.push({
                            'Nom de la table': tableName,
                            'Nombre de lignes': count,
                            'Nombre de colonnes': columnCount,
                            'Stockage': 'SQLite (SQL.js)',
                            'Type': tableName === 'dioo_donnees' ? 'Donn√©es principales' : 
                                   tableName === 'dioo_summary' ? 'Consolidation' : 'M√©tadonn√©es'
                        });
                    }
                    
                    const rawDataInfoTables = {
                        requete_sql: sqlInfoTables,
                        engine: 'SQL.js natif',
                        tables_trouvees: tables,
                        resultats: resultats,
                        timestamp: new Date().toISOString()
                    };
                    afficherDetailsRequete(sqlInfoTables, 'Informations tables SQL.js', rawDataInfoTables);
                    
                    console.log(`‚úÖ DataBase - Informations collect√©es pour ${resultats.length} tables SQLite`);
                } catch (error) {
                    console.error('‚ùå Erreur SQL info_tables:', error);
                    afficherErreur(`Erreur SQL: ${error.message}`);
                    return;
                }
                break;
                
            case 'total_lignes':
                console.log('üìä DataBase - Calcul du total des lignes [SQL.js NATIF]');
                titre = 'Total des lignes';
                
                try {
                    // üöÄ Ex√©cution directe SQL.js - Plus de parsing custom !
                    const sqlTotalLignes = 'SELECT COUNT(*) as count FROM dioo_donnees';
                    resultats = await window.DatabaseManager.executeQuery(sqlTotalLignes);
                    
                    // Adapter le format pour compatibilit√© affichage
                    resultats = [{ 'Nombre de lignes': resultats[0].count }];
                    
                    const rawDataTotalLignes = {
                        requete_sql: sqlTotalLignes,
                        engine: 'SQL.js natif',
                        resultats: resultats,
                        timestamp: new Date().toISOString()
                    };
                    afficherDetailsRequete(sqlTotalLignes, 'Total des lignes SQL.js', rawDataTotalLignes);
                    
                    console.log(`‚úÖ DataBase - Total calcul√© via SQL.js: ${resultats[0]['Nombre de lignes']} lignes`);
                } catch (error) {
                    console.error('‚ùå Erreur SQL total_lignes:', error);
                    afficherErreur(`Erreur SQL: ${error.message}`);
                    return;
                }
                break;
                
            case 'premieres_lignes':
                console.log('üìä DataBase - Affichage des premi√®res lignes [SQL.js NATIF]');
                titre = 'Premi√®res lignes de la table';
                
                try {
                    // üöÄ Ex√©cution directe SQL.js - Plus de parsing custom !
                    const sqlPremieres = 'SELECT * FROM dioo_donnees LIMIT 10';
                    resultats = await window.DatabaseManager.executeQuery(sqlPremieres);
                    
                    console.log(`‚úÖ DataBase - ${resultats.length} premi√®res lignes r√©cup√©r√©es via SQL.js`);
                    
                    // Afficher les d√©tails avec le r√©sultat brut
                    const rawData = {
                        requete_sql: sqlPremieres,
                        engine: 'SQL.js natif',
                        resultats: resultats,
                        nombre_resultats: resultats.length,
                        timestamp: new Date().toISOString()
                    };
                    afficherDetailsRequete(sqlPremieres, 'Premi√®res lignes SQL.js', rawData);
                } catch (error) {
                    console.error('‚ùå Erreur SQL premieres_lignes:', error);
                    afficherErreur(`Erreur SQL: ${error.message}`);
                    return;
                }
                break;
                
            case 'criticites':
                console.log('üìä DataBase - Analyse des criticit√©s');
                titre = 'R√©partition des criticit√©s';
                
                // Afficher les d√©tails de la requ√™te SQL √©quivalente
                const sqlCriticites = 'SELECT "Business criticality", COUNT(*) AS count FROM dioo_donnees GROUP BY "Business criticality" ORDER BY count DESC;';
                const rawDataCriticites = {
                    lignes_brutes: lignes.slice(0, 10),
                    headers: headers,
                    nombre_lignes_total: lignes.length
                };
                // Afficher d'abord sans les r√©sultats trait√©s
                afficherDetailsRequete(sqlCriticites, 'R√©partition des criticit√©s', rawDataCriticites);
                const indices = trouverIndicesColonnes(headers);
                console.log('üîç DataBase - Indices trouv√©s:', indices);
                
                if (indices.businessCriticality === -1) {
                    console.error('‚ùå DataBase - Colonne Business Criticality non trouv√©e');
                    throw new Error('Colonne Business Criticality non trouv√©e dans les donn√©es');
                }
                
                const criticites = {};
                
                lignes.forEach((ligne, index) => {
                    const criticite = ligne[indices.businessCriticality] || 'Non d√©fini';
                    criticites[criticite] = (criticites[criticite] || 0) + 1;
                    if (index < 5) { // Log des 5 premi√®res lignes pour debug
                        console.log(`üîç DataBase - Ligne ${index}: criticit√© = "${criticite}"`);
                    }
                });
                
                console.log('üìä DataBase - Criticit√©s trouv√©es:', criticites);
                
                resultats = Object.entries(criticites).map(([criticite, count]) => ({
                    'Business Criticality': criticite,
                    'Nombre': count
                }));
                
                // Mettre √† jour les donn√©es brutes avec les r√©sultats trait√©s
                rawDataCriticites.resultats_traites = resultats;
                rawDataCriticites.criticites_trouvees = criticites;
                break;
                
            case 'prefixes_dp':
                titre = 'Pr√©fixes DP*';
                
                // Afficher les d√©tails de la requ√™te SQL √©quivalente
                const sqlPrefixes = 'SELECT SUBSTR("Dx", 1, 3) AS prefixe, COUNT(*) AS count FROM dioo_donnees WHERE "Dx" LIKE "DP%" GROUP BY prefixe ORDER BY count DESC;';
                const indicesDP = trouverIndicesColonnes(headers);
                const lignesDPPrefixes = lignes.filter(ligne => {
                    const dValue = ligne[indicesDP.d] || '';
                    return dValue.toString().toUpperCase().startsWith('DP');
                });
                const rawDataPrefixes = {
                    lignes_brutes: lignesDPPrefixes.slice(0, 10),
                    headers: headers,
                    nombre_lignes_total: lignes.length,
                    nombre_lignes_dp: lignesDPPrefixes.length
                };
                afficherDetailsRequete(sqlPrefixes, 'Pr√©fixes DP*', rawDataPrefixes);
                const prefixes = {};
                
                lignes.forEach(ligne => {
                    const dValue = ligne[indicesDP.d] || '';
                    if (dValue.toString().toUpperCase().startsWith('DP')) {
                        const prefix = dValue.toString().substring(0, 3).toUpperCase();
                        prefixes[prefix] = (prefixes[prefix] || 0) + 1;
                    }
                });
                
                resultats = Object.entries(prefixes).map(([prefix, count]) => ({
                    'Pr√©fixe': prefix,
                    'Nombre': count
                }));
                
                // Mettre √† jour les donn√©es brutes avec les r√©sultats trait√©s
                rawDataPrefixes.resultats_traites = resultats;
                rawDataPrefixes.prefixes_trouves = prefixes;
                break;
                
            case 'vue_ensemble':
                titre = 'Vue d\'ensemble des donn√©es';
                
                // Afficher les d√©tails de la requ√™te SQL √©quivalente
                const sqlVueEnsemble = 'SELECT COUNT(*) AS total_lignes, COUNT(DISTINCT "Business criticality") AS criticites_uniques, COUNT(DISTINCT "Dx") AS identifiants_uniques FROM dioo_donnees;';
                const rawDataVueEnsemble = {
                    lignes_brutes: lignes.slice(0, 10),
                    headers: headers,
                    nombre_lignes_total: lignes.length
                };
                afficherDetailsRequete(sqlVueEnsemble, 'Vue d\'ensemble', rawDataVueEnsemble);
                
                const indicesVue = trouverIndicesColonnes(headers);
                const totalLignes = lignes.length;
                const lignesDPVue = lignes.filter(ligne => {
                    const dValue = ligne[indicesVue.d] || '';
                    return dValue.toString().toUpperCase().startsWith('DP');
                }).length;
                const lignesCritical = lignes.filter(ligne => {
                    const criticite = ligne[indicesVue.businessCriticality] || '';
                    return criticite.toString().toUpperCase() === 'CRITICAL';
                }).length;
                const lignesDPCritical = lignes.filter(ligne => {
                    const dValue = ligne[indicesVue.d] || '';
                    const criticite = ligne[indicesVue.businessCriticality] || '';
                    return dValue.toString().toUpperCase().startsWith('DP') && 
                           criticite.toString().toUpperCase() === 'CRITICAL';
                }).length;
                
                resultats = [{
                    'M√©trique': 'Total des lignes',
                    'Valeur': totalLignes
                }, {
                    'M√©trique': 'Lignes DP*',
                    'Valeur': lignesDPVue
                }, {
                    'M√©trique': 'Lignes Critical',
                    'Valeur': lignesCritical
                }, {
                    'M√©trique': 'Lignes DP* + Critical',
                    'Valeur': lignesDPCritical
                }];
                
                // Mettre √† jour les donn√©es brutes avec les r√©sultats trait√©s
                rawDataVueEnsemble.resultats_traites = resultats;
                rawDataVueEnsemble.statistiques = {
                    totalLignes,
                    lignesDP: lignesDPVue,
                    lignesCritical,
                    lignesDPCritical
                };
                break;
                
            case 'ajouter_ligne_aleatoire':
                console.log('üé≤ D√âBUT - Cas ajouter_ligne_aleatoire atteint');
                console.log('üìä DataBase - Ajout d\'une ligne al√©atoire');
                console.log(`üîç Headers disponibles: ${headers.length} colonnes`);
                console.log(`üîç Lignes actuelles: ${lignes.length}`);
                
                titre = 'Ligne al√©atoire ajout√©e';
                
                try {
                    // V√©rifier que nous avons des headers
                    if (!headers || headers.length === 0) {
                        console.error('‚ùå Aucun header disponible pour g√©n√©rer une ligne');
                        throw new Error('Aucune structure de donn√©es disponible');
                    }
                    
                    // Afficher les d√©tails de la requ√™te SQL √©quivalente
                    const sqlAjouterLigne = `INSERT INTO dioo_donnees (${headers.map(h => `"${h}"`).join(', ')}) VALUES (${headers.map(() => '?').join(', ')});`;
                    console.log(`üîß Requ√™te SQL g√©n√©r√©e: ${sqlAjouterLigne}`);
                    
                    // G√©n√©rer une ligne al√©atoire
                    console.log('üé≤ G√©n√©ration de la ligne al√©atoire...');
                    const nouvelleLigne = genererLigneAleatoire(headers);
                    console.log('üé≤ Ligne g√©n√©r√©e:', nouvelleLigne);
                    console.log(`üé≤ Longueur ligne g√©n√©r√©e: ${nouvelleLigne.length}`);
                    
                    // V√©rifier que la ligne a la bonne longueur
                    if (nouvelleLigne.length !== headers.length) {
                        console.error(`‚ùå Erreur: ligne g√©n√©r√©e (${nouvelleLigne.length}) ne correspond pas aux headers (${headers.length})`);
                        throw new Error('Erreur de g√©n√©ration de ligne');
                    }
                    
                    // Ajouter la ligne aux donn√©es
                    console.log('üíæ Ajout de la ligne aux donn√©es...');
                    lignes.push(nouvelleLigne);
                    console.log(`‚úÖ Ligne ajout√©e. Nouveau total: ${lignes.length}`);
                    
                    // Sauvegarder dans SQLite
                    console.log('üíæ Sauvegarde dans SQLite...');
                    await sauvegarderDonneesModifiees(lignes, headers);
                    console.log('‚úÖ Sauvegarde termin√©e');
                    
                    // Ajouter au dump d'insertion
                    console.log('üìã Ajout au dump d\'insertion...');
                    const sqlTemplate = `INSERT INTO dioo_donnees (${headers.map(h => `"${h}"`).join(', ')}) VALUES (${headers.map(() => '?').join(', ')})`;
                    const sqlComplete = construireRequeteSQL(sqlTemplate, nouvelleLigne);
                    ajouterAuDumpInsertion(sqlComplete, nouvelleLigne, nouvelleLigne[0]);
                    
                    // Afficher les d√©tails de la requ√™te
                    console.log('üîç Affichage des d√©tails de la requ√™te...');
                    afficherDetailsRequete(sqlComplete, 'Ajout ligne al√©atoire', {
                        ligne_ajoutee: nouvelleLigne,
                        nouveau_total: lignes.length,
                        identifiant: nouvelleLigne[0],
                        headers: headers
                    });
                    
                    // Pr√©parer les r√©sultats
                    resultats = [{
                        'Action': 'Ligne ajout√©e',
                        'Identifiant': nouvelleLigne[0],
                        'Total lignes': lignes.length,
                        'Colonnes': headers.length
                    }];
                    
                    console.log(`‚úÖ SUCC√àS - Ligne al√©atoire ajout√©e. Nouveau total: ${lignes.length}`);
                    
                } catch (error) {
                    console.error('‚ùå ERREUR lors de l\'ajout de ligne al√©atoire:', error);
                    console.error('‚ùå Stack trace:', error.stack);
                    
                    afficherErreur(`Erreur lors de l'ajout de ligne: ${error.message}`);
                    return;
                }
                break;
                
            default:
                afficherErreur(`Type de requ√™te non reconnu: ${queryType}`);
                return;
        }
        
        console.log(`üìã DataBase - Affichage des r√©sultats: ${resultats.length} √©l√©ments`);
        console.log('üîç DataBase - R√©sultats √† afficher:', resultats);
        afficherResultats(resultats, titre);
        
    } catch (error) {
        console.error('‚ùå DataBase - Erreur lors de l\'ex√©cution de la requ√™te:', error);
        console.error('‚ùå DataBase - Stack trace:', error.stack);
        afficherErreur(`Erreur: ${error.message}`);
    }
}

/**
 * Wrapper synchrone pour executeCustomQuery (appel√© depuis HTML)
 */
function executeCustomQuery() {
    executeCustomQueryAsync().catch(error => {
        console.error('‚ùå Erreur executeCustomQuery:', error);
        afficherErreur(`Erreur: ${error.message}`);
    });
}

/**
 * Ex√©cuter une requ√™te personnalis√©e (version async)
 */
async function executeCustomQueryAsync() {
    console.log('üîç DataBase - D√©but ex√©cution requ√™te personnalis√©e [SQL.js NATIF]');
    
    const queryInput = document.getElementById('custom-query-input');
    if (!queryInput) {
        console.error('‚ùå DataBase - √âl√©ment custom-query-input non trouv√© dans le DOM');
        afficherErreur('Erreur: √âl√©ment de saisie non trouv√©.');
        return;
    }
    
    const query = queryInput.value.trim();
    console.log(`üîç DataBase - Requ√™te SQL.js: "${query}" (${query.length} caract√®res)`);
    
    if (!query) {
        console.log('‚ö†Ô∏è DataBase - Requ√™te vide');
        afficherErreur('Veuillez entrer une requ√™te SQL.');
        return;
    }
    
    // V√©rifier que DatabaseManager est pr√™t
    if (!window.DatabaseManager.isInitialized()) {
        console.error('‚ùå DataBase - DatabaseManager non initialis√©');
        afficherErreur('Base de donn√©es non initialis√©e. Veuillez recharger la page.');
        return;
    }
    
    console.log(`‚úÖ DataBase - Ex√©cution directe avec SQL.js (plus de parsing custom)`);
    
    try {
        const timestamp = new Date().toISOString();
        console.log(`‚è∞ DataBase - Ex√©cution SQL.js √† ${timestamp}`);
        
        // üöÄ R√âVOLUTION: Ex√©cution directe avec SQL.js - Plus de parsing custom !
        console.log(`üö® CUSTOM_QUERY - Ex√©cution DIRECTE via SQL.js natif`);
        const resultats = await window.DatabaseManager.executeQuery(query);
        console.log(`‚úÖ CUSTOM_QUERY - SQL.js natif: ${resultats.length} r√©sultats`);
        
        // Structure simplifi√©e - Plus d'analyse custom obsol√®te
        const rawDataCustomQuery = {
            requete_sql: query,
            engine: 'SQL.js natif (SQLite WebAssembly)',
            resultats: resultats,
            nombre_resultats: resultats.length,
            timestamp: timestamp,
            database_info: await window.DatabaseManager.getInfo()
        };
        
        // Affichage des d√©tails et r√©sultats
        afficherDetailsRequete(query, 'SQL.js natif', rawDataCustomQuery);
        
        const titreAvecTimestamp = `SQL.js natif (${new Date().toLocaleTimeString()})`;
        afficherResultats(resultats, titreAvecTimestamp);
        
    } catch (error) {
        console.error('‚ùå DataBase - Erreur SQL.js natif:', error);
        
        // üéØ Erreurs SQL pr√©cises de SQLite (plus d'erreurs custom vagues)
        let errorMessage = error.message;
        if (errorMessage.includes('syntax error')) {
            errorMessage = '‚ùå Erreur de syntaxe SQL. V√©rifiez votre requ√™te.';
        } else if (errorMessage.includes('no such table')) {
            errorMessage = '‚ùå Table inexistante. Tables disponibles: dioo_donnees, dioo_summary, dioo_metadata';
        } else if (errorMessage.includes('no such column')) {
            errorMessage = '‚ùå Colonne inexistante. Utilisez PRAGMA table_info(dioo_donnees) pour voir les colonnes.';
        } else if (errorMessage.includes('ambiguous column name')) {
            errorMessage = '‚ùå Nom de colonne ambigu. Sp√©cifiez la table (ex: dioo_donnees.Dx)';
        }
        
        console.error('‚ùå DataBase - Erreur SQL d√©taill√©e:', errorMessage);
        afficherErreur(`Erreur SQL: ${errorMessage}`);
    }
}

// ‚úÖ FONCTION SUPPRIM√âE: executerFiltreSimple() - Remplac√©e par SQL.js natif

// ‚úÖ FONCTION SUPPRIM√âE: filtrerLignesAvecWhere() - Remplac√©e par SQL.js natif

/**
 * Trouver l'index d'une colonne par son nom
 */
function trouverIndexColonne(headers, nomColonne) {
    return headers.findIndex(header => 
        header.toLowerCase().includes(nomColonne.toLowerCase())
    );
}

/**
 * Afficher les r√©sultats dans la section r√©sultats
 */
function afficherResultats(resultats, titre) {
    // Identifier la source de l'appel
    const stack = new Error().stack;
    const sourceInfo = stack.split('\n')[2] || 'Source inconnue';
    
    console.log(`üìã DataBase - afficherResultats appel√©e avec titre: "${titre}"`);
    console.log(`üìã DataBase - Source de l'appel: ${sourceInfo}`);
    console.log(`üìã DataBase - Nombre de r√©sultats: ${resultats ? resultats.length : 'undefined'}`);
    console.log(`üîç DEBUG - Type des r√©sultats:`, typeof resultats, Array.isArray(resultats));
    console.log(`üîç DEBUG - R√©sultats re√ßus:`, resultats);
    
    // Analyser chaque r√©sultat pour les caract√®res sp√©ciaux
    if (resultats && resultats.length > 0) {
        resultats.forEach((ligne, index) => {
            console.log(`üîç DEBUG - Ligne ${index}:`, ligne);
            Object.entries(ligne).forEach(([colonne, valeur]) => {
                const valeurStr = String(valeur);
                const hasSpecialChars = /[^\x20-\x7E]/.test(valeurStr);
                const isEmpty = valeurStr === '' || valeurStr === 'undefined' || valeurStr === 'null';
                
                if (isEmpty) {
                    console.log(`‚ö†Ô∏è DEBUG - ${colonne}: VIDE (${valeurStr})`);
                } else if (hasSpecialChars) {
                    console.log(`üö® DEBUG - ${colonne}: CARACT√àRES SP√âCIAUX d√©tect√©s: "${valeurStr}"`);
                } else {
                    console.log(`‚úÖ DEBUG - ${colonne}: OK "${valeurStr}"`);
                }
            });
        });
    }
    
    const resultsDiv = document.getElementById('query-results');
    const resultsSection = document.getElementById('results-section');
    const resultsLed = document.getElementById('results-led');
    const resultsContent = document.getElementById('results-content');
    
    console.log(`üîç DataBase - √âl√©ments DOM trouv√©s:`, {
        resultsDiv: !!resultsDiv,
        resultsSection: !!resultsSection,
        resultsLed: !!resultsLed,
        resultsContent: !!resultsContent
    });
    
    if (!resultats || resultats.length === 0) {
        console.log('‚ö†Ô∏è DataBase - Aucun r√©sultat √† afficher');
        resultsDiv.innerHTML = '<p class="no-results">Aucun r√©sultat trouv√©.</p>';
        return;
    }
    
    // V√©rifier si c'est un r√©sultat COUNT avec 0
    if (resultats.length === 1 && resultats[0]['Nombre de lignes'] === 0) {
        console.log('‚ö†Ô∏è DataBase - COUNT(*) retourne 0');
        resultsDiv.innerHTML = '<p class="no-results">Aucun r√©sultat trouv√©.</p>';
        return;
    }
    
    console.log('‚úÖ DataBase - G√©n√©ration du tableau HTML');
    console.log('üîç DataBase - Premier r√©sultat:', resultats[0]);
    
    // Activer la section r√©sultats
    resultsContent.style.display = 'block';
    resultsLed.classList.add('active');
    document.getElementById('results-arrow').classList.add('rotated');
    
    // V√©rifier si on a besoin de pagination (plus de 50 r√©sultats)
    if (resultats.length > 50) {
        console.log('üìÑ DataBase - Activation de la pagination pour', resultats.length, 'r√©sultats');
        const colonnes = Object.keys(resultats[0]);
        initialiserPaginationResultats(resultats, colonnes);
    } else {
        // Affichage normal sans pagination
        console.log('üìÑ DataBase - Affichage direct sans pagination');
        
        // Masquer les contr√¥les de pagination
        const controlsDiv = document.getElementById('results-controls');
        if (controlsDiv) {
            controlsDiv.style.display = 'none';
        }
        
        // Cr√©er le HTML des r√©sultats
        let html = `<div class="results-count">${resultats.length} r√©sultat(s) trouv√©(s) - ${titre}</div>`;
        
        if (resultats.length > 0) {
            const colonnes = Object.keys(resultats[0]);
            
            html += '<table class="results-table">';
            html += '<thead><tr>';
            colonnes.forEach(colonne => {
                html += `<th>${colonne}</th>`;
            });
            html += '</tr></thead>';
            
            html += '<tbody>';
            resultats.forEach((ligne, ligneIndex) => {
                console.log(`üîç DEBUG - G√©n√©ration ligne ${ligneIndex}:`, ligne);
                html += '<tr>';
                colonnes.forEach(colonne => {
                    const valeur = ligne[colonne] || '';
                    const valeurStr = String(valeur);
                    const hasSpecialChars = /[^\x20-\x7E]/.test(valeurStr);
                    
                    console.log(`üîç DEBUG - Cellule [${ligneIndex}][${colonne}]: "${valeurStr}" (${valeurStr.length} car.)`);
                    
                    if (hasSpecialChars) {
                        console.log(`üö® DEBUG - Caract√®res sp√©ciaux d√©tect√©s dans [${ligneIndex}][${colonne}]`);
                        // Nettoyer les caract√®res sp√©ciaux pour l'affichage
                        const valeurNettoyee = valeurStr.replace(/[^\x20-\x7E]/g, '?');
                        html += `<td title="Caract√®res sp√©ciaux d√©tect√©s">${valeurNettoyee}</td>`;
                    } else {
                        html += `<td>${valeurStr}</td>`;
                    }
                });
                html += '</tr>';
            });
            html += '</tbody></table>';
            
            console.log(`‚úÖ DEBUG - HTML g√©n√©r√© (${html.length} caract√®res):`, html.substring(0, 500) + '...');
        }
        
        resultsDiv.innerHTML = html;
    }
}

/**
 * Afficher un message d'erreur
 */
function afficherErreur(message) {
    const resultsDiv = document.getElementById('query-results');
    const resultsContent = document.getElementById('results-content');
    const resultsLed = document.getElementById('results-led');
    
    // Activer la section r√©sultats
    resultsContent.style.display = 'block';
    resultsLed.classList.add('active');
    document.getElementById('results-arrow').classList.add('rotated');
    
    resultsDiv.innerHTML = `<div class="error-message">${message}</div>`;
}

/**
 * Afficher les d√©tails d'une requ√™te dans la section pliable
 */
function afficherDetailsRequete(sqlQuery, type = 'Requ√™te pr√©d√©finie', rawResult = null) {
    console.log(`üîç Affichage des d√©tails de requ√™te: "${sqlQuery}" (${type})`);
    
    const querySent = document.getElementById('query-sent');
    const queryTimestamp = document.getElementById('query-timestamp');
    const queryType = document.getElementById('query-type');
    
    if (querySent && queryTimestamp && queryType) {
        querySent.textContent = sqlQuery;
        queryTimestamp.textContent = new Date().toLocaleString();
        queryType.textContent = type;
        
        // Toujours afficher le contenu brut du r√©sultat
        const queryInfo = document.getElementById('query-info');
        if (queryInfo) {
            // Chercher ou cr√©er la section de r√©sultat brut
            let rawResultDiv = document.getElementById('raw-result-section');
            if (!rawResultDiv) {
                rawResultDiv = document.createElement('div');
                rawResultDiv.id = 'raw-result-section';
                rawResultDiv.style.marginTop = '15px';
                rawResultDiv.style.padding = '10px';
                rawResultDiv.style.backgroundColor = 'rgba(163,177,199,0.05)';
                rawResultDiv.style.borderRadius = '5px';
                rawResultDiv.style.border = '1px solid rgba(163,177,199,0.2)';
                queryInfo.appendChild(rawResultDiv);
            }
            
            let rawResultHTML = `
                <div class="summary-header" onclick="toggleRawResultSection()" style="background: rgba(163,177,199,0.05); padding: 8px 15px; cursor: pointer; border-radius: 5px; margin-bottom: 10px;">
                    <div class="section-title">
                        <div class="led-indicator" id="raw-result-led"></div>
                        <h5 style="margin: 0; font-size: 14px;">Contenu brut du r√©sultat</h5>
                    </div>
                    <div class="arrow-indicator" id="raw-result-arrow">
                        ‚ñº
                    </div>
                </div>
                <div class="summary-content" id="raw-result-content" style="display: none;">
                    <div style="display: flex; gap: 10px; margin-bottom: 15px;">
                        <button onclick="effacerContenuBrut()" class="btn btn-danger" style="padding: 6px 12px; font-size: 12px;" title="Effacer le contenu">Effacer</button>
                        <button onclick="copierContenuBrut()" class="btn" style="padding: 6px 12px; font-size: 12px; background: #4ecdc4; color: white;" title="Copier dans le presse-papier">Copier</button>
                    </div>
            `;
            
            if (rawResult !== null) {
                // Afficher le r√©sultat brut complet
                rawResultHTML += '<div id="contenu-brut-container" style="background: rgba(0,0,0,0.1); padding: 10px; border-radius: 3px; font-family: monospace; font-size: 11px; max-height: 300px; overflow-y: auto;">';
                rawResultHTML += '<pre id="contenu-brut-pre" style="margin: 0; white-space: pre-wrap; word-wrap: break-word;">';
                rawResultHTML += JSON.stringify(rawResult, null, 2);
                rawResultHTML += '</pre>';
                rawResultHTML += '</div>';
            } else {
                rawResultHTML += '<div style="color: #ff6b6b; font-style: italic;">Aucun r√©sultat brut disponible</div>';
            }
            
            // Fermer la div du contenu pliable
            rawResultHTML += '</div>';
            
            rawResultDiv.innerHTML = rawResultHTML;
        }
        
        // Afficher et ouvrir la section des d√©tails de requ√™te
        const queryDetailsSection = document.getElementById('query-details-content');
        const queryDetailsLed = document.getElementById('query-details-led');
        const queryDetailsArrow = document.getElementById('query-details-arrow');
        
        if (queryDetailsSection && queryDetailsLed && queryDetailsArrow) {
            queryDetailsSection.style.display = 'block';
            queryDetailsLed.classList.add('active');
            queryDetailsArrow.textContent = '‚ñ≤';
        }
        
        console.log('‚úÖ D√©tails de requ√™te affich√©s avec contenu brut');
    } else {
        console.error('‚ùå Impossible de trouver les √©l√©ments DOM pour les d√©tails de requ√™te');
    }
}

// ‚úÖ FONCTION SUPPRIM√âE: creerRequeteSQLJS() - Remplac√©e par SQL.js natif

/**
 * Fonction de diagnostic rapide pour v√©rifier les donn√©es
 */
function diagnosticRapide() {
    console.log('üîç DIAGNOSTIC RAPIDE - V√©rification des donn√©es');
    
    const donnees = JSON.parse(localStorage.getItem('dioo_donnees') || '{}');
    console.log('üìä Donn√©es brutes:', donnees);
    
    let lignes, headers;
    let nombreLignes = 0;
    
    if (donnees.donnees && donnees.donnees.donnees) {
        lignes = donnees.donnees.donnees;
        headers = donnees.donnees.headers || [];
        nombreLignes = lignes.length;
        console.log(`‚úÖ Structure imbriqu√©e: ${nombreLignes} lignes, ${headers.length} colonnes`);
    } else if (Array.isArray(donnees.donnees)) {
        lignes = donnees.donnees;
        headers = donnees.headers || [];
        nombreLignes = lignes.length;
        console.log(`‚úÖ Structure directe: ${nombreLignes} lignes, ${headers.length} colonnes`);
    } else {
        console.log('‚ùå Aucune donn√©e trouv√©e dans localStorage');
        return { lignes: 0, headers: 0, status: 'Aucune donn√©e charg√©e' };
    }
    
    // V√©rifier aussi les m√©tadonn√©es
    const metadata = donnees.metadata || {};
    const fichierInfo = donnees.fichier || {};
    
    console.log('üìã Headers:', headers);
    console.log('üìã Premi√®re ligne:', lignes[0]);
    console.log(`üìä R√âSULTAT: ${nombreLignes} lignes dans la base de donn√©es`);
    
    return {
        lignes: nombreLignes,
        headers: headers.length,
        status: nombreLignes > 0 ? 'OK' : 'Base vide',
        premiereligne: lignes[0],
        headers_list: headers,
        fichier: fichierInfo,
        metadata: metadata,
        message: `La base contient ${nombreLignes} lignes de donn√©es`
    };
}

/**
 * Fonction simple pour obtenir juste le nombre de lignes
 */
function compterLignes() {
    // Utiliser StorageManager et extractDataStructure
    const donnees = StorageManager.getDonnees();
    const { lignes } = extractDataStructure(donnees);
    
    return lignes ? lignes.length : 0;
}

/**
 * G√©n√©rer une ligne al√©atoire avec identifiant incr√©mental
 */
function genererLigneAleatoire(headers) {
    console.log('üé≤ G√©n√©ration d\'une ligne al√©atoire...');
    console.log('üîç Headers disponibles:', headers);
    
    const ligne = [];
    
    // Obtenir le prochain num√©ro d'incr√©ment
    const compteurRand = obtenirProchainCompteurRand();
    
    for (let i = 0; i < headers.length; i++) {
        const header = headers[i];
        
        if (i === 0) {
            // Premier champ : identifiant incr√©mental "Rand_XXX"
            const identifiant = `Rand_${compteurRand.toString().padStart(3, '0')}`;
            ligne.push(identifiant);
            console.log(`üè∑Ô∏è Identifiant g√©n√©r√©: ${identifiant}`);
        } else {
            // Autres champs : valeurs al√©atoires bas√©es sur le nom de la colonne
            const valeurAleatoire = genererValeurAleatoire(header);
            ligne.push(valeurAleatoire);
        }
    }
    
    console.log('‚úÖ Ligne al√©atoire g√©n√©r√©e:', ligne);
    return ligne;
}

/**
 * Obtenir le prochain compteur pour les identifiants Rand_XXX
 */
function obtenirProchainCompteurRand() {
    // Utiliser StorageManager pour incr√©menter le compteur
    const compteur = StorageManager.incrementRandCounter();
    
    console.log(`üî¢ Prochain compteur Rand via StorageManager: ${compteur}`);
    return compteur;
}

/**
 * G√©n√©rer une valeur al√©atoire bas√©e sur le nom de la colonne
 */
function genererValeurAleatoire(nomColonne) {
    const nomLower = nomColonne.toLowerCase();
    
    // Valeurs sp√©cifiques selon le type de colonne
    if (nomLower.includes('criticality') || nomLower.includes('critical')) {
        const criticites = ['Critical', 'High', 'Medium', 'Low'];
        return criticites[Math.floor(Math.random() * criticites.length)];
    }
    
    if (nomLower.includes('monitoring') || nomLower.includes('monitor')) {
        return Math.random() > 0.5 ? 'YES' : 'NO';
    }
    
    if (nomLower.includes('hcc')) {
        return Math.random() > 0.5 ? 'YES' : 'NO';
    }
    
    if (nomLower.includes('eligibility') || nomLower.includes('eligible')) {
        return Math.random() > 0.5 ? 'YES' : 'NO';
    }
    
    if (nomLower.includes('dx') || nomLower.includes('d*') || nomLower.includes('id') || nomLower.includes('identifier')) {
        const prefixes = ['DP', 'DA', 'DB', 'DC', 'DD'];
        const prefix = prefixes[Math.floor(Math.random() * prefixes.length)];
        const numero = Math.floor(Math.random() * 9999) + 1;
        return `${prefix}${numero.toString().padStart(4, '0')}`;
    }
    
    if (nomLower.includes('operator') || nomLower.includes('department')) {
        const departments = ['IT Operations', 'Network Services', 'Security Team', 'Database Admin', 'System Admin', 'DevOps Team'];
        return departments[Math.floor(Math.random() * departments.length)];
    }
    
    if (nomLower.includes('app appli') || nomLower.includes('appli')) {
        const noms = ['Service Alpha', 'Application Beta', 'System Gamma', 'Module Delta', 'Component Epsilon', 'Portal Web', 'API Gateway', 'Database Service'];
        return noms[Math.floor(Math.random() * noms.length)];
    }
    
    if (nomLower.includes('app code') || nomLower.includes('code')) {
        const codes = ['SRV001', 'APP002', 'SYS003', 'MOD004', 'CMP005', 'WEB006', 'API007', 'DB008'];
        return codes[Math.floor(Math.random() * codes.length)];
    }
    
    if (nomLower.includes('name') || nomLower.includes('nom')) {
        const noms = ['Service Alpha', 'Application Beta', 'System Gamma', 'Module Delta', 'Component Epsilon'];
        return noms[Math.floor(Math.random() * noms.length)];
    }
    
    if (nomLower.includes('status') || nomLower.includes('√©tat')) {
        const statuts = ['Active', 'Inactive', 'Pending', 'Completed'];
        return statuts[Math.floor(Math.random() * statuts.length)];
    }
    
    if (nomLower.includes('date')) {
        const maintenant = new Date();
        const dateAleatoire = new Date(maintenant.getTime() - Math.random() * 365 * 24 * 60 * 60 * 1000);
        return dateAleatoire.toISOString().split('T')[0];
    }
    
    if (nomLower.includes('number') || nomLower.includes('count') || nomLower.includes('nb')) {
        return Math.floor(Math.random() * 100) + 1;
    }
    
    // Valeur par d√©faut : texte al√©atoire
    const textesAleatoires = ['Lorem', 'Ipsum', 'Dolor', 'Sit', 'Amet', 'Consectetur', 'Adipiscing', 'Elit'];
    return textesAleatoires[Math.floor(Math.random() * textesAleatoires.length)];
}

/**
 * Sauvegarder les donn√©es modifi√©es dans localStorage
 */
async function sauvegarderDonneesModifiees(lignes, headers) {
    console.log('üíæ Sauvegarde des donn√©es modifi√©es [SQL.js NATIF]...');
    console.log(`üíæ Lignes √† sauvegarder: ${lignes.length}`);
    console.log(`üíæ Headers √† sauvegarder: ${headers.length}`);
    
    try {
        // üöÄ Sauvegarde directe avec DatabaseManager - Plus de localStorage !
        console.log('üíæ Sauvegarde directe via DatabaseManager SQL.js');
        const success = await window.DatabaseManager.setDonnees(lignes, headers);
        
        if (success) {
            console.log(`‚úÖ ${lignes.length} lignes sauvegard√©es via SQL.js`);
            
            // V√©rification avec DatabaseManager
            const stats = await window.DatabaseManager.getStats();
            console.log(`‚úÖ V√©rification SQL.js: ${stats.donnees.dataLength} lignes en base`);
        } else {
            throw new Error('√âchec de la sauvegarde via DatabaseManager');
        }
        
    } catch (error) {
        console.error('‚ùå Erreur lors de la sauvegarde SQL.js:', error);
        console.error('‚ùå Stack trace:', error.stack);
        throw error;
    }
}

/**
 * Basculer l'affichage de la section contenu brut
 */
function toggleRawResultSection() {
    console.log('üîÑ Toggle de la section contenu brut');
    
    const content = document.getElementById('raw-result-content');
    const led = document.getElementById('raw-result-led');
    const arrow = document.getElementById('raw-result-arrow');
    
    if (!content || !led || !arrow) {
        console.error('‚ùå √âl√©ments de la section contenu brut non trouv√©s');
        return;
    }
    
    const isVisible = content.style.display !== 'none';
    
    if (isVisible) {
        // Fermer la section
        content.style.display = 'none';
        led.style.background = '#888'; // LED grise
        led.classList.remove('active');
        arrow.textContent = '‚ñº';
        console.log('üìÅ Section contenu brut ferm√©e');
    } else {
        // Ouvrir la section
        content.style.display = 'block';
        led.style.background = '#4ecdc4'; // LED verte
        led.classList.add('active');
        arrow.textContent = '‚ñ≤';
        console.log('üìÇ Section contenu brut ouverte');
    }
}

/**
 * Effacer le contenu brut du r√©sultat
 */
function effacerContenuBrut() {
    console.log('üóëÔ∏è Effacement du contenu brut du r√©sultat');
    
    const contenuBrutPre = document.getElementById('contenu-brut-pre');
    const contenuBrutContainer = document.getElementById('contenu-brut-container');
    
    if (contenuBrutPre) {
        contenuBrutPre.textContent = '';
        console.log('‚úÖ Contenu brut effac√©');
    }
    
    if (contenuBrutContainer) {
        contenuBrutContainer.innerHTML = '<div style="color: #888; font-style: italic; text-align: center; padding: 20px;">Contenu effac√©</div>';
        console.log('‚úÖ Container mis √† jour avec message d\'effacement');
    }
}

/**
 * Copier le contenu brut dans le presse-papier
 */
function copierContenuBrut() {
    console.log('üìã Copie du contenu brut dans le presse-papier');
    
    const contenuBrutPre = document.getElementById('contenu-brut-pre');
    
    if (!contenuBrutPre) {
        console.error('‚ùå √âl√©ment contenu-brut-pre non trouv√©');
        alert('Erreur: Contenu non trouv√©');
        return;
    }
    
    const contenu = contenuBrutPre.textContent;
    
    if (!contenu || contenu.trim() === '') {
        console.log('‚ö†Ô∏è Contenu vide, rien √† copier');
        alert('Aucun contenu √† copier');
        return;
    }
    
    // Utiliser l'API Clipboard moderne si disponible
    if (navigator.clipboard && navigator.clipboard.writeText) {
        navigator.clipboard.writeText(contenu)
            .then(() => {
                console.log('‚úÖ Contenu copi√© dans le presse-papier via Clipboard API');
                alert('Contenu copi√© dans le presse-papier !');
            })
            .catch(err => {
                console.error('‚ùå Erreur lors de la copie via Clipboard API:', err);
                // Fallback vers la m√©thode traditionnelle
                copierAvecFallback(contenu);
            });
    } else {
        // Fallback pour les navigateurs plus anciens
        copierAvecFallback(contenu);
    }
}

/**
 * M√©thode de fallback pour copier le contenu
 */
function copierAvecFallback(contenu) {
    console.log('üìã Utilisation de la m√©thode de fallback pour la copie');
    
    try {
        // Cr√©er un √©l√©ment textarea temporaire
        const textarea = document.createElement('textarea');
        textarea.value = contenu;
        textarea.style.position = 'fixed';
        textarea.style.opacity = '0';
        document.body.appendChild(textarea);
        
        // S√©lectionner et copier
        textarea.select();
        textarea.setSelectionRange(0, 99999); // Pour mobile
        
        const success = document.execCommand('copy');
        document.body.removeChild(textarea);
        
        if (success) {
            console.log('‚úÖ Contenu copi√© dans le presse-papier via fallback');
            alert('Contenu copi√© dans le presse-papier !');
        } else {
            console.error('‚ùå √âchec de la copie via fallback');
            alert('Erreur lors de la copie');
        }
    } catch (err) {
        console.error('‚ùå Erreur lors de la copie via fallback:', err);
        alert('Erreur lors de la copie: ' + err.message);
    }
}

/**
 * Fonctions de pagination pour les r√©sultats de la page DataBase
 */

function initialiserPaginationResultats(resultats, headers) {
    console.log('üìÑ Initialisation pagination r√©sultats:', resultats.length, 'lignes');
    
    window.resultsData.donnees = resultats;
    window.resultsData.headers = headers || [];
    window.resultsData.pageActuelle = 1;
    window.resultsData.totalPages = Math.ceil(resultats.length / window.resultsData.lignesParPage);
    
    // Afficher les contr√¥les si plus d'une page
    const controlsDiv = document.getElementById('results-controls');
    if (controlsDiv) {
        controlsDiv.style.display = window.resultsData.totalPages > 1 ? 'flex' : 'none';
    }
    
    // Mettre √† jour les contr√¥les
    mettreAJourControlesNavigationResultats();
    
    // G√©n√©rer la premi√®re page
    genererTableauResultatsPagine();
}

function genererTableauResultatsPagine() {
    const debut = (window.resultsData.pageActuelle - 1) * window.resultsData.lignesParPage;
    const fin = Math.min(debut + window.resultsData.lignesParPage, window.resultsData.donnees.length);
    
    const resultatsPage = window.resultsData.donnees.slice(debut, fin);
    
    console.log(`üìÑ G√©n√©ration page ${window.resultsData.pageActuelle}: lignes ${debut}-${fin}`);
    
    // Utiliser la fonction existante mais avec les donn√©es pagin√©es
    const resultsDiv = document.getElementById('query-results');
    if (!resultsDiv || resultatsPage.length === 0) return;
    
    // Cr√©er le HTML du tableau
    let html = `<div class="results-count">${window.resultsData.donnees.length} r√©sultat(s) trouv√©(s) - Page ${window.resultsData.pageActuelle}/${window.resultsData.totalPages}</div>`;
    
    if (resultatsPage.length > 0) {
        const colonnes = Object.keys(resultatsPage[0]);
        
        html += '<table class="results-table">';
        html += '<thead><tr>';
        colonnes.forEach(colonne => {
            html += `<th>${colonne}</th>`;
        });
        html += '</tr></thead>';
        
        html += '<tbody>';
        resultatsPage.forEach((ligne) => {
            html += '<tr>';
            colonnes.forEach(colonne => {
                const valeur = ligne[colonne] || '';
                html += `<td>${String(valeur)}</td>`;
            });
            html += '</tr>';
        });
        html += '</tbody></table>';
    }
    
    resultsDiv.innerHTML = html;
    
    // Mettre √† jour les informations
    mettreAJourControlesNavigationResultats();
}

function mettreAJourControlesNavigationResultats() {
    const currentPageInput = document.getElementById('results-current-page');
    const totalPagesSpan = document.getElementById('results-total-pages');
    const lignesAfficheesSpan = document.getElementById('results-lignes-affichees');
    const totalLignesSpan = document.getElementById('results-total-lignes');
    
    if (currentPageInput) currentPageInput.value = window.resultsData.pageActuelle;
    if (totalPagesSpan) totalPagesSpan.textContent = window.resultsData.totalPages;
    
    const debut = (window.resultsData.pageActuelle - 1) * window.resultsData.lignesParPage;
    const fin = Math.min(debut + window.resultsData.lignesParPage, window.resultsData.donnees.length);
    
    if (lignesAfficheesSpan) lignesAfficheesSpan.textContent = fin - debut;
    if (totalLignesSpan) totalLignesSpan.textContent = window.resultsData.donnees.length;
    
    // G√©rer l'√©tat des boutons
    const firstBtn = document.getElementById('results-first-page');
    const prevBtn = document.getElementById('results-prev-page');
    const nextBtn = document.getElementById('results-next-page');
    const lastBtn = document.getElementById('results-last-page');
    
    if (firstBtn) firstBtn.disabled = window.resultsData.pageActuelle === 1;
    if (prevBtn) prevBtn.disabled = window.resultsData.pageActuelle === 1;
    if (nextBtn) nextBtn.disabled = window.resultsData.pageActuelle === window.resultsData.totalPages;
    if (lastBtn) lastBtn.disabled = window.resultsData.pageActuelle === window.resultsData.totalPages;
}

function allerPremierePageResultats() {
    window.resultsData.pageActuelle = 1;
    genererTableauResultatsPagine();
}

function pagePrecedenteResultats() {
    if (window.resultsData.pageActuelle > 1) {
        window.resultsData.pageActuelle--;
        genererTableauResultatsPagine();
    }
}

function pageSuivanteResultats() {
    if (window.resultsData.pageActuelle < window.resultsData.totalPages) {
        window.resultsData.pageActuelle++;
        genererTableauResultatsPagine();
    }
}

function allerDernierePageResultats() {
    window.resultsData.pageActuelle = window.resultsData.totalPages;
    genererTableauResultatsPagine();
}

function allerALaPageResultats(numeroPage) {
    const page = parseInt(numeroPage);
    if (page >= 1 && page <= window.resultsData.totalPages) {
        window.resultsData.pageActuelle = page;
        genererTableauResultatsPagine();
    }
}

/**
 * Exposition de l'API pour le d√©bogage
 */
window.dioo = {
    navigateTo: (page) => window.diooApp?.navigateToPage(page),
    getState: () => window.diooApp?.getAppState(),
    reset: () => window.diooApp?.reset(),
    version: 'v0.000-stable-extract-viewer-database',
    // Nouvelles fonctions
    diagnostic: diagnosticRapide,
    compterLignes: compterLignes,
    effacerDonnees: effacerDonnees,
    testEffacement: () => {
        console.log('üß™ TEST - Avant effacement:', compterLignes(), 'lignes');
        effacerDonnees();
        setTimeout(() => {
            console.log('üß™ TEST - Apr√®s effacement:', compterLignes(), 'lignes');
        }, 100);
    },
    ajouterLigneAleatoire: () => {
        console.log('üß™ TEST - Ajout ligne al√©atoire via API');
        console.log('üß™ Nombre de lignes avant:', compterLignes());
        executeQuery('ajouter_ligne_aleatoire');
        setTimeout(() => {
            console.log('üß™ Nombre de lignes apr√®s:', compterLignes());
        }, 1000);
    },
    testBouton: () => {
        console.log('üß™ TEST DIRECT - Simulation clic bouton');
        const bouton = document.querySelector('button[onclick="executeQuery(\'ajouter_ligne_aleatoire\')"]');
        if (bouton) {
            console.log('‚úÖ Bouton trouv√©:', bouton);
            bouton.click();
        } else {
            console.error('‚ùå Bouton non trouv√©');
        }
    },
    genererLigne: genererLigneAleatoire,
    chargerFichier: chargerFichierDIOO,
    gererClicCharger: gererClicCharger,
    reinitialiser: reinitialiserEtats,
    getLocalStorage: () => JSON.parse(localStorage.getItem('dioo_donnees') || '{}'),
    // Fonctions Dump
    toggleDump: toggleDumpSection,
    getDumpData: () => window.dumpData,
    // Fonctions Monitoring
    calculerConsolidation: calculerConsolidation,
    getSummary: () => JSON.parse(localStorage.getItem('dioo_summary') || '[]'),
    toggleSection: toggleSection,
    // Fonctions DataBase
    toggleDatabaseSection: toggleDatabaseSection,
    executeQuery: executeQuery,
    executeCustomQuery: executeCustomQuery,
    // creerRequeteSQLJS: creerRequeteSQLJS, // DEPRECATED - Utiliser SQLParser.createSQLJSQuery()
    testCustomQuery: () => {
        console.log('üß™ Test de la requ√™te personnalis√©e');
        const queryInput = document.getElementById('custom-query-input');
        if (queryInput) {
            console.log('‚úÖ √âl√©ment trouv√©, valeur actuelle:', queryInput.value);
            executeCustomQuery();
        } else {
            console.error('‚ùå √âl√©ment custom-query-input non trouv√©');
        }
    },
    testSQLJS: (query) => {
        const donnees = JSON.parse(localStorage.getItem('dioo_donnees') || '{}');
        let headers = [];
        if (donnees.donnees && donnees.donnees.headers) {
            headers = donnees.donnees.headers;
        }
        return creerRequeteSQLJS(query || 'SELECT COUNT(*) FROM dioo_donnees;', headers);
    },
    // Utilitaires
    afficher10Lignes: afficher10PremiersLignes,
    debugLocalStorage: () => {
        const donnees = JSON.parse(localStorage.getItem('dioo_donnees') || '{}');
        console.log('üîç Debug localStorage:', donnees);
        console.log('üîç Cl√©s disponibles:', Object.keys(donnees));
        if (donnees.donnees) {
            console.log('üîç Type de donnees.donnees:', typeof donnees.donnees, Array.isArray(donnees.donnees));
            if (donnees.donnees.donnees) {
                console.log('üîç Type de donnees.donnees.donnees:', typeof donnees.donnees.donnees, Array.isArray(donnees.donnees.donnees));
            }
        }
        return donnees;
    },
    // Fonctions de gestion du contenu brut
    toggleRawResultSection: toggleRawResultSection,
    effacerContenuBrut: effacerContenuBrut,
    copierContenuBrut: copierContenuBrut
};

/*===============================================
  FONCTIONS AFFICHAGE REQU√äTES SQL
===============================================*/

/**
 * Afficher la section des requ√™tes SQL
 */
function afficherSectionRequetesSQL() {
    const section = document.getElementById('sql-queries-section');
    if (section) {
        section.style.display = 'block';
        // Vider la liste des requ√™tes pr√©c√©dentes
        viderListeRequetesSQL();
    }
}

/**
 * Vider la liste des requ√™tes SQL
 */
function viderListeRequetesSQL() {
    const liste = document.getElementById('sql-query-list');
    if (liste) {
        liste.innerHTML = '<p class="no-queries">Calcul en cours...</p>';
    }
}

/**
 * Effacer compl√®tement le dump SQL
 */
function effacerDumpSQL() {
    const liste = document.getElementById('import-dump-list');
    if (liste) {
        liste.innerHTML = '<div class="dump-empty" id="import-dump-empty"><p>Aucune erreur d√©tect√©e</p><p class="dump-empty-hint">Toutes les erreurs d\'import, validation et insertion DB appara√Ætront ici avec d√©tails techniques</p></div>';
        console.log('üßπ Dump SQL effac√©');
    }
    
    // R√©initialiser le compteur
    const countElement = document.getElementById('import-dump-count');
    if (countElement) {
        countElement.textContent = '0';
    }
}

/**
 * Ajouter une erreur au dump pour qu'elle reste visible
 */
function ajouterErreurAuDump(titre, messageErreur) {
    const timestamp = new Date().toLocaleTimeString();
    
    // Ajouter √† la section des requ√™tes SQL comme une erreur persistante
    ajouterRequeteSQL(
        `‚ùå ${titre}`, 
        `Erreur survenue √† ${timestamp}`, 
        null, 
        messageErreur
    );
    
    // Aussi l'ajouter √† la section dump d'insertion si elle existe
    const dumpSection = document.getElementById('dump-content');
    if (dumpSection) {
        const errorDiv = document.createElement('div');
        errorDiv.className = 'dump-error-message';
        errorDiv.innerHTML = `
            <div class="error-header">‚ùå ${titre} - ${timestamp}</div>
            <div class="error-details">${messageErreur}</div>
        `;
        dumpSection.appendChild(errorDiv);
    }
}

/**
 * Diagnostiquer les erreurs actuelles dans le dump
 */
function diagnostiquerErreurs() {
    console.log('üîç DIAGNOSTIC ERREURS:');
    
    const liste = document.getElementById('import-dump-list');
    const countElement = document.getElementById('import-dump-count');
    
    console.log('- Liste dump trouv√©e:', !!liste);
    console.log('- Compteur trouv√©:', !!countElement);
    console.log('- Compteur valeur:', countElement?.textContent);
    console.log('- Contenu liste:', liste?.innerHTML?.substring(0, 200));
    
    const erreurs = liste?.querySelectorAll('.error-item');
    console.log('- Nombre d\'erreurs dans DOM:', erreurs?.length || 0);
    
    if (erreurs && erreurs.length > 0) {
        erreurs.forEach((erreur, index) => {
            const titre = erreur.querySelector('.sql-query-title')?.textContent;
            const message = erreur.querySelector('.error-message')?.textContent;
            console.log(`  Erreur ${index + 1}: ${titre} - ${message}`);
        });
    }
    
    return {
        listeExiste: !!liste,
        compteurExiste: !!countElement,
        compteurValeur: countElement?.textContent,
        nombreErreurs: erreurs?.length || 0
    };
}

/**
 * Ajouter une requ√™te SQL √† l'affichage - ERREURS UNIQUEMENT
 */
function ajouterRequeteSQL(titre, requete, resultat = null, erreur = null) {
    const liste = document.getElementById('import-dump-list');
    if (!liste) return;
    
    // NOUVELLE LOGIQUE: N'afficher que les erreurs dans le dump
    if (!erreur) {
        // Si ce n'est pas une erreur, ne pas l'afficher dans le dump
        return;
    }
    
    // Supprimer le message "aucune requ√™te" et "aucune erreur d√©tect√©e"
    const noQueries = liste.querySelector('.no-queries');
    if (noQueries) {
        noQueries.remove();
    }
    
    // Supprimer le message "Aucune erreur d√©tect√©e" s'il existe
    const noErrors = liste.querySelector('.dump-empty');
    if (noErrors) {
        noErrors.remove();
    }
    
    const timestamp = new Date().toLocaleTimeString();
    const fullTimestamp = new Date().toISOString();
    
    const queryItem = document.createElement('div');
    queryItem.className = 'sql-query-item error-item';
    
    // D√©tails techniques de l'erreur
    let detailsTechniques = '';
    if (erreur) {
        detailsTechniques = `
            <div class="error-technical-details">
                <div class="error-header">
                    <strong>üîç D√âTAILS TECHNIQUES DE L'ERREUR</strong>
                </div>
                <div class="error-details">
                    <div><strong>Timestamp complet:</strong> ${fullTimestamp}</div>
                    <div><strong>Message d'erreur:</strong> ${erreur}</div>
                    <div><strong>Contexte:</strong> ${titre}</div>
                    <div><strong>Requ√™te/Action:</strong> ${requete || 'N/A'}</div>
                    <div><strong>Type d'erreur:</strong> ${erreur.includes('localStorage') ? 'Storage' : erreur.includes('JSON') ? 'S√©rialisation' : erreur.includes('SQL') ? 'Base de donn√©es' : 'G√©n√©rique'}</div>
                </div>
            </div>
        `;
    }
    
    queryItem.innerHTML = `
        <div class="sql-query-header error-header">
            <div class="sql-query-title">‚ùå ${titre}</div>
            <div class="sql-query-time">${timestamp}</div>
        </div>
        <div class="sql-query-error">
            <div class="error-message">üí• ${erreur}</div>
            ${detailsTechniques}
        </div>
        ${requete ? `<div class="sql-query-code">Contexte: ${requete}</div>` : ''}
    `;
    
    liste.appendChild(queryItem);
    
    // Afficher automatiquement la section des erreurs
    const section = document.getElementById('import-dump-section');
    if (section) {
        section.style.display = 'block';
        // Ouvrir la section si elle est ferm√©e
        const content = document.getElementById('import-dump-content');
        const arrow = document.getElementById('import-dump-arrow');
        if (content && content.style.display === 'none') {
            content.style.display = 'block';
            if (arrow) arrow.innerHTML = '‚ñº';
        }
    }
    
    // Scroll vers le bas pour voir la nouvelle erreur
    liste.scrollTop = liste.scrollHeight;
    
    // Mettre √† jour le compteur d'erreurs
    const countElement = document.getElementById('import-dump-count');
    if (countElement) {
        const currentCount = parseInt(countElement.textContent) || 0;
        countElement.textContent = currentCount + 1;
    }
}

/**
 * Effectuer les calculs de consolidation avec SQL natif
 */
async function effectuerCalculsConsolidationSQL() {
    console.log('üéØ Calculs de consolidation avec requ√™tes SQL natives');
    
    try {
        // 1. Compter le total d'applications critiques
        const queryTotalCritiques = `
            SELECT COUNT(*) as total 
            FROM dioo_donnees 
            WHERE UPPER("Dx") = 'DP' 
            AND UPPER("Operator/Department") like 'DP%'
            AND UPPER("Business criticality") = 'CRITICAL'        `;
        
        const totalCritiques = await executerRequeteSQL('Total Applications Critiques', queryTotalCritiques);
        
        // 2. BSM - Monitored in BSM
        const queryMonitoredBSM = `
            SELECT COUNT(*) as count 
            FROM dioo_donnees 
            WHERE UPPER("Dx") = 'DP' 
            AND UPPER("Business criticality") = 'CRITICAL'
            AND UPPER("Operator/Department") like 'DP%'
            AND UPPER("Functional monitoring (BSM)") = 'YES'
        `;
        
        const monitoredBSM = await executerRequeteSQL('BSM - Monitored', queryMonitoredBSM);
        
        // 3. BSM - Still To Be Monitored
        const queryStillToMonitor = `
            SELECT COUNT(*) as count 
            FROM dioo_donnees 
            WHERE UPPER("Dx") = 'DP' 
            AND UPPER("Business criticality") = 'CRITICAL'
            AND UPPER("Operator/Department") like 'DP%'
            AND UPPER("In HCC") = 'NO'
        `;
        
        const stillToMonitor = await executerRequeteSQL('BSM - Still To Monitor', queryStillToMonitor);
        
        // 4. HCC - Confirmed Not Required in BSM
        const queryNotRequiredBSM = `
            SELECT COUNT(*) as count 
            FROM dioo_donnees 
            WHERE UPPER("Dx") = 'DP' 
            AND UPPER("Business criticality") = 'CRITICAL'
            AND UPPER("Operator/Department") like 'DP%'
            AND UPPER("Functional monitoring (BSM)") = 'NO'
            AND UPPER("HCC eligibility") = 'NO'
        `;
        
        const notRequiredBSM = await executerRequeteSQL('HCC - Not Required BSM', queryNotRequiredBSM);
        
        // 5. HCC - Monitored in HCC
        const queryMonitoredHCC = `
            SELECT COUNT(*) as count 
            FROM dioo_donnees 
            WHERE UPPER("Dx") = 'DP' 
            AND UPPER("Operator/Department") like 'DP%'
            AND UPPER("Business criticality") = 'CRITICAL'
            AND UPPER("In HCC") = 'YES'
        `;
        
        const monitoredHCC = await executerRequeteSQL('HCC - Monitored', queryMonitoredHCC);
        
        // 6. HCC - Confirmed not required in HCC
        const queryNotRequiredHCC = `
            SELECT COUNT(*) as count 
            FROM dioo_donnees 
            WHERE UPPER("Dx") = 'DP' 
            AND UPPER("Operator/Department") like 'DP%'
            AND UPPER("Business criticality") = 'CRITICAL'
            AND UPPER("In HCC") = 'NO'
            AND UPPER("HCC eligibility") = 'NO'
        `;
        
        const notRequiredHCC = await executerRequeteSQL('HCC - Not Required', queryNotRequiredHCC);
        
        // Calculer les sections DP avec SQL
        const sectionsDP = await calculerSectionsDPSQL();

        // Calculer le total de toutes les sections DP pour le pourcentage
        const totalSectionsDP = Object.values(sectionsDP).reduce((sum, section) => sum + section.total, 0);

        
        // Calculer les pourcentages
        const pctSectionsDP = totalCritiques > 0 ? Math.round((stillToMonitor / totalCritiques) * 100) : 0;
        const pctNotRequiredBSM = totalCritiques > 0 ? Math.round((notRequiredBSM / totalCritiques) * 100) : 0;
        const pctMonitoredHCC = totalCritiques > 0 ? Math.round((monitoredHCC / totalCritiques) * 100) : 0;
        const pctNotRequiredHCC = totalCritiques > 0 ? Math.round((notRequiredHCC / totalCritiques) * 100) : 0;
        
        // Cr√©er la structure attendue pour la section DP principale
        const dpPrincipal = {
            criticalBusinessServices: totalCritiques,
            stillToOnboard: stillToMonitor
        };
        
        // Ajouter la section DP principale aux sections
        sectionsDP.dp = dpPrincipal;
        
        const resultats = {
            date: new Date().toISOString().split('T')[0],
            totalCritiques,
            monitoredBSM,
            stillToMonitor,
            notRequiredBSM,
            pctNotRequiredBSM,
            monitoredHCC,
            notRequiredHCC,
            pctMonitoredHCC,
            pctNotRequiredHCC,
            pctSectionsDP,
            totalSectionsDP,
            sectionsDP: sectionsDP
        };
        
        console.log('‚úÖ Calculs de consolidation SQL termin√©s:', resultats);
        return resultats;
        
    } catch (error) {
        console.error('‚ùå Erreur dans les calculs SQL:', error);
        ajouterRequeteSQL('ERREUR', 'Calculs de consolidation', null, error.message);
        throw error;
    }
}

/**
 * Ex√©cuter une requ√™te SQL et afficher le r√©sultat
 */
async function executerRequeteSQL(titre, requete) {
    try {
        const results = await window.DatabaseManager.executeQuery(requete);
        const valeur = results[0] ? (results[0].total || results[0].count || 0) : 0;
        
        ajouterRequeteSQL(titre, requete, valeur);
        return valeur;
        
    } catch (error) {
        ajouterRequeteSQL(titre, requete, null, error.message);
        throw error;
    }
}

/**
 * Calculer les sections DP avec SQL
 */
async function calculerSectionsDPSQL() {
    const sections = {};
    
    // Pour chaque section DP (DP1, DP2, DP3, DP4, DP5)
    const dpTypes = ['DP1', 'DP2', 'DP3', 'DP4', 'DP5'];
    
    for (const dpType of dpTypes) {
        // Compter le total pour ce type DP
        const queryTotal = `
            SELECT COUNT(*) as count 
            FROM dioo_donnees 
            WHERE UPPER("Dx") = '${dpType}' 
            AND UPPER("Business criticality") = 'CRITICAL'
        `;
        
        // Compter les monitored pour ce type DP
        const queryMonitored = `
            SELECT COUNT(*) as count 
            FROM dioo_donnees 
            WHERE UPPER("Dx") = '${dpType}' 
            AND UPPER("Business criticality") = 'CRITICAL'
            AND UPPER("Functional monitoring (BSM)") = 'YES'
        `;
        
        try {
            const total = await executerRequeteSQL(`Section ${dpType} - Total`, queryTotal);
            const monitored = await executerRequeteSQL(`Section ${dpType} - Monitored`, queryMonitored);
            
            // Mapper vers les noms de sections attendus (dpa, dpb, etc.)
            let sectionKey;
            switch(dpType) {
                case 'DP1': sectionKey = 'dpa'; break;
                case 'DP2': sectionKey = 'dpb'; break;
                case 'DP3': sectionKey = 'dpc'; break;
                case 'DP4': sectionKey = 'dpp'; break;
                case 'DP5': sectionKey = 'dps'; break;
                default: sectionKey = dpType.toLowerCase();
            }
            sections[sectionKey] = { total, monitored };
            
        } catch (error) {
            console.error(`Erreur calcul section ${dpType}:`, error);
            let sectionKey;
            switch(dpType) {
                case 'DP1': sectionKey = 'dpa'; break;
                case 'DP2': sectionKey = 'dpb'; break;
                case 'DP3': sectionKey = 'dpc'; break;
                case 'DP4': sectionKey = 'dpp'; break;
                case 'DP5': sectionKey = 'dps'; break;
                default: sectionKey = dpType.toLowerCase();
            }
            sections[sectionKey] = { total: 0, monitored: 0 };
        }
    }
    
    return sections;
}