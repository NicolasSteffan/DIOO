/**
 * DatabaseManager - Gestionnaire de base de donn√©es SQLite avec SQL.js
 * 
 * Remplace StorageManager et SQLParser par une vraie base de donn√©es SQLite en m√©moire
 * 
 * @version v0.000C-SQLjs-Migration
 * @author DIOO Team
 */

class DatabaseManager {
    constructor() {
        this.db = null;
        this.SQL = null;
        this.initialized = false;
        this.migrationCompleted = false;
    }

    /**
     * Initialiser SQL.js et cr√©er la base de donn√©es
     */
    async init() {
        console.log('üöÄ DatabaseManager - Initialisation SQL.js...');
        
        try {
            // Initialiser SQL.js
            this.SQL = await initSqlJs({
                locateFile: file => `./${file}`
            });
            
            console.log('‚úÖ SQL.js initialis√© avec succ√®s');
            
            // Cr√©er une nouvelle base de donn√©es en m√©moire
            this.db = new this.SQL.Database();
            console.log('‚úÖ Base de donn√©es SQLite cr√©√©e en m√©moire');
            
            // Cr√©er les tables
            this.createTables();
            
            this.initialized = true;
            console.log('üéâ DatabaseManager initialis√© avec succ√®s !');
            
            return true;
        } catch (error) {
            console.error('‚ùå Erreur lors de l\'initialisation de DatabaseManager:', error);
            throw error;
        }
    }

    /**
     * Cr√©er les tables de base
     */
    createTables() {
        console.log('üèóÔ∏è Cr√©ation des tables SQLite...');
        
        try {
            // Table principale des donn√©es
            this.db.run(`
                CREATE TABLE IF NOT EXISTS dioo_donnees (
                    id INTEGER PRIMARY KEY AUTOINCREMENT,
                    "Dx" TEXT,
                    "App Appli" TEXT,
                    "App Code" TEXT,
                    "Operator/Department" TEXT,
                    "Business criticality" TEXT,
                    "Functional monitoring (BSM)" TEXT,
                    "In HCC" TEXT,
                    "HCC eligibility" TEXT,
                    created_at DATETIME DEFAULT CURRENT_TIMESTAMP
                )
            `);
            
            // Table de consolidation/summary
            this.db.run(`
                CREATE TABLE IF NOT EXISTS dioo_summary (
                    id INTEGER PRIMARY KEY AUTOINCREMENT,
                    type TEXT NOT NULL,
                    value INTEGER NOT NULL,
                    percentage REAL,
                    date_tag TEXT,
                    created_at DATETIME DEFAULT CURRENT_TIMESTAMP
                )
            `);
            
            // Table de m√©tadonn√©es
            this.db.run(`
                CREATE TABLE IF NOT EXISTS dioo_metadata (
                    key TEXT PRIMARY KEY,
                    value TEXT,
                    updated_at DATETIME DEFAULT CURRENT_TIMESTAMP
                )
            `);
            
            // Ins√©rer les m√©tadonn√©es de base
            this.db.run(`
                INSERT OR REPLACE INTO dioo_metadata (key, value) 
                VALUES ('version', 'v0.000C-SQLjs-Migration')
            `);
            
            this.db.run(`
                INSERT OR REPLACE INTO dioo_metadata (key, value) 
                VALUES ('rand_counter', '0')
            `);
            
            console.log('‚úÖ Tables SQLite cr√©√©es avec succ√®s');
            
        } catch (error) {
            console.error('‚ùå Erreur lors de la cr√©ation des tables:', error);
            throw error;
        }
    }

    /**
     * Ex√©cuter une requ√™te SQL
     */
    async executeQuery(sql, params = []) {
        if (!this.initialized) {
            throw new Error('DatabaseManager non initialis√©. Appelez init() d\'abord.');
        }
        
        console.log(`üîç DatabaseManager - Ex√©cution SQL: "${sql}"`);
        if (params.length > 0) {
            console.log(`üìã Param√®tres:`, params);
        }
        
        try {
            const stmt = this.db.prepare(sql);
            
            if (sql.trim().toLowerCase().startsWith('select')) {
                // Requ√™te SELECT - retourner les r√©sultats
                const results = [];
                while (stmt.step()) {
                    const row = stmt.getAsObject();
                    results.push(row);
                }
                stmt.free();
                
                console.log(`‚úÖ Requ√™te SELECT ex√©cut√©e: ${results.length} r√©sultats`);
                return results;
                
            } else {
                // Requ√™te INSERT/UPDATE/DELETE
                if (params.length > 0) {
                    stmt.bind(params);
                }
                stmt.step();
                const changes = this.db.getRowsModified();
                stmt.free();
                
                console.log(`‚úÖ Requ√™te ${sql.split(' ')[0]} ex√©cut√©e: ${changes} lignes affect√©es`);
                return { changes, lastInsertRowid: this.db.exec("SELECT last_insert_rowid()")[0]?.values[0]?.[0] };
            }
            
        } catch (error) {
            console.error('‚ùå Erreur SQL:', error);
            console.error('‚ùå Requ√™te:', sql);
            console.error('‚ùå Param√®tres:', params);
            throw new Error(`Erreur SQL: ${error.message}`);
        }
    }

    /**
     * Ins√©rer des donn√©es (remplace StorageManager.setDonnees)
     */
    async setDonnees(lignes, headers) {
        console.log(`üíæ DatabaseManager - Insertion de ${lignes.length} lignes`);
        
        try {
            // Vider la table existante
            await this.executeQuery('DELETE FROM dioo_donnees');
            
            // Pr√©parer la requ√™te d'insertion
            const placeholders = headers.map(() => '?').join(', ');
            const columnNames = headers.map(h => `"${h}"`).join(', ');
            const insertSQL = `INSERT INTO dioo_donnees (${columnNames}) VALUES (${placeholders})`;
            
            console.log(`üîß Requ√™te d'insertion: ${insertSQL}`);
            
            // Ins√©rer chaque ligne
            let inserted = 0;
            for (const ligne of lignes) {
                const values = headers.map(header => ligne[header] || '');
                await this.executeQuery(insertSQL, values);
                inserted++;
                
                if (inserted % 1000 === 0) {
                    console.log(`üìä Progression: ${inserted}/${lignes.length} lignes ins√©r√©es`);
                }
            }
            
            console.log(`‚úÖ ${inserted} lignes ins√©r√©es avec succ√®s`);
            return true;
            
        } catch (error) {
            console.error('‚ùå Erreur lors de l\'insertion:', error);
            throw error;
        }
    }

    /**
     * R√©cup√©rer les donn√©es (remplace StorageManager.getDonnees)
     */
    async getDonnees() {
        console.log('üìñ DatabaseManager - R√©cup√©ration des donn√©es');
        
        try {
            const lignes = await this.executeQuery('SELECT * FROM dioo_donnees ORDER BY id');
            const headers = await this.getHeaders();
            
            console.log(`‚úÖ ${lignes.length} lignes r√©cup√©r√©es`);
            
            // Retourner dans le format attendu par extractDataStructure
            return {
                donnees: {
                    donnees: lignes,
                    headers: headers
                },
                metadata: {
                    nombreLignes: lignes.length,
                    version: 'v0.000C-SQLjs-Migration'
                }
            };
            
        } catch (error) {
            console.error('‚ùå Erreur lors de la r√©cup√©ration:', error);
            throw error;
        }
    }

    /**
     * Obtenir les headers des colonnes
     */
    async getHeaders() {
        try {
            const result = this.db.exec("PRAGMA table_info(dioo_donnees)");
            if (result.length === 0) {
                return ['Dx', 'App Appli', 'App Code', 'Operator/Department', 'Business criticality', 'Functional monitoring (BSM)', 'In HCC', 'HCC eligibility'];
            }
            
            const headers = result[0].values
                .filter(row => row[1] !== 'id' && row[1] !== 'created_at') // Exclure les colonnes techniques
                .map(row => row[1]); // Nom de la colonne
            
            return headers;
        } catch (error) {
            console.error('‚ùå Erreur lors de la r√©cup√©ration des headers:', error);
            return [];
        }
    }

    /**
     * Obtenir les statistiques (remplace StorageManager.getStats)
     */
    async getStats() {
        console.log('üìä DatabaseManager - Calcul des statistiques');
        
        try {
            const donneesCount = await this.executeQuery('SELECT COUNT(*) as count FROM dioo_donnees');
            const summaryCount = await this.executeQuery('SELECT COUNT(*) as count FROM dioo_summary');
            
            const stats = {
                donnees: {
                    exists: donneesCount[0].count > 0,
                    dataLength: donneesCount[0].count,
                    headersLength: (await this.getHeaders()).length,
                    sizeBytes: 0 // TODO: Calculer la taille r√©elle
                },
                summary: {
                    exists: summaryCount[0].count > 0,
                    length: summaryCount[0].count,
                    sizeBytes: 0 // TODO: Calculer la taille r√©elle
                }
            };
            
            console.log('‚úÖ Statistiques calcul√©es:', stats);
            return stats;
            
        } catch (error) {
            console.error('‚ùå Erreur lors du calcul des statistiques:', error);
            throw error;
        }
    }

    /**
     * Incr√©menter le compteur al√©atoire (remplace StorageManager.incrementRandCounter)
     */
    async incrementRandCounter() {
        try {
            const current = await this.executeQuery(
                "SELECT value FROM dioo_metadata WHERE key = 'rand_counter'"
            );
            
            const currentValue = current.length > 0 ? parseInt(current[0].value) : 0;
            const newValue = currentValue + 1;
            
            await this.executeQuery(
                "UPDATE dioo_metadata SET value = ?, updated_at = CURRENT_TIMESTAMP WHERE key = 'rand_counter'",
                [newValue.toString()]
            );
            
            console.log(`üî¢ Compteur al√©atoire incr√©ment√©: ${newValue}`);
            return newValue;
            
        } catch (error) {
            console.error('‚ùå Erreur lors de l\'incr√©mentation du compteur:', error);
            throw error;
        }
    }

    /**
     * Effacer toutes les donn√©es (remplace StorageManager.clearAll)
     */
    async clearAll() {
        console.log('üóëÔ∏è DatabaseManager - Effacement de toutes les donn√©es');
        
        try {
            await this.executeQuery('DELETE FROM dioo_donnees');
            await this.executeQuery('DELETE FROM dioo_summary');
            await this.executeQuery("UPDATE dioo_metadata SET value = '0' WHERE key = 'rand_counter'");
            
            console.log('‚úÖ Toutes les donn√©es effac√©es');
            return { success: true, message: 'Donn√©es effac√©es avec succ√®s' };
            
        } catch (error) {
            console.error('‚ùå Erreur lors de l\'effacement:', error);
            return { success: false, message: error.message };
        }
    }

    /**
     * Migrer depuis localStorage (fonction de transition)
     */
    async migrateFromLocalStorage() {
        if (this.migrationCompleted) {
            console.log('‚ÑπÔ∏è Migration d√©j√† effectu√©e');
            return true;
        }
        
        console.log('üîÑ D√©but de la migration localStorage ‚Üí SQLite');
        
        try {
            // R√©cup√©rer les anciennes donn√©es
            const oldData = JSON.parse(localStorage.getItem('dioo_donnees') || '{}');
            
            if (!oldData.donnees) {
                console.log('‚ÑπÔ∏è Aucune donn√©e √† migrer');
                this.migrationCompleted = true;
                return true;
            }
            
            // Utiliser extractDataStructure pour la compatibilit√©
            const { lignes, headers } = window.extractDataStructure ? 
                window.extractDataStructure(oldData) : 
                { lignes: [], headers: [] };
            
            if (lignes.length > 0) {
                console.log(`üîÑ Migration de ${lignes.length} lignes...`);
                await this.setDonnees(lignes, headers);
                console.log('‚úÖ Migration des donn√©es termin√©e');
            }
            
            // Migrer le summary si pr√©sent
            const oldSummary = JSON.parse(localStorage.getItem('dioo_summary') || '[]');
            if (oldSummary.length > 0) {
                console.log(`üîÑ Migration de ${oldSummary.length} √©l√©ments de summary...`);
                // TODO: Migrer le summary
            }
            
            this.migrationCompleted = true;
            console.log('üéâ Migration termin√©e avec succ√®s !');
            return true;
            
        } catch (error) {
            console.error('‚ùå Erreur lors de la migration:', error);
            throw error;
        }
    }

    /**
     * V√©rifier si la base est initialis√©e
     */
    isInitialized() {
        return this.initialized;
    }

    /**
     * Obtenir des informations sur la base
     */
    async getInfo() {
        if (!this.initialized) {
            return { status: 'Non initialis√©' };
        }
        
        try {
            const tables = await this.executeQuery(
                "SELECT name FROM sqlite_master WHERE type='table'"
            );
            
            const stats = await this.getStats();
            
            return {
                status: 'Initialis√©',
                version: 'v0.000C-SQLjs-Migration',
                tables: tables.map(t => t.name),
                stats: stats,
                migrationCompleted: this.migrationCompleted
            };
            
        } catch (error) {
            console.error('‚ùå Erreur lors de la r√©cup√©ration des infos:', error);
            return { status: 'Erreur', error: error.message };
        }
    }
}

// Instance globale
window.DatabaseManager = new DatabaseManager();

console.log('üì¶ DatabaseManager charg√© - Pr√™t pour l\'initialisation');